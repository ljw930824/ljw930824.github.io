[{"title":"阿里巴巴Java开源项目","date":"2019-06-25T16:38:11.000Z","path":"2019/06/26/阿里巴巴Java开源项目/阿里巴巴Java开源项目/","text":"1.分布式应用服务开发的一站式解决方案 Spring Cloud Alibaba Spring Cloud Alibaba 致力于提供分布式应用服务开发的一站式解决方案。此项目包含开发分布式应用服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。 依托 Spring Cloud Alibaba，您只需要添加一些注解和少量配置，就可以将 Spring Cloud 应用接入阿里分布式应用解决方案，通过阿里中间件来迅速搭建分布式应用系统。 地址：https://github.com/spring-cloud-incubator/spring-cloud-alibaba 2.JDBC 连接池、监控组件 Druid Druid是一个 JDBC 组件。 1.监控数据库访问性能。 2.提供了一个高效、功能强大、可扩展性好的数据库连接池。 3.数据库密码加密。 4.SQL执行日志。 地址：https://github.com/alibaba/druid 3.Java 的 JSON 处理器 fastjson fastjson 是一个性能很好的 Java 语言实现的 JSON 解析器和生成器，来自阿里巴巴的工程师开发。 主要特点：快速FAST (比其它任何基于Java的解析器和生成器更快，包括jackson）；强大（支持普通JDK类包括任意Java Bean Class、Collection、Map、Date或enum）；零依赖（没有依赖其它任何类库除了JDK）。 地址：https://github.com/alibaba/fastjson 4.服务框架 Dubbo Apache Dubbo (incubating) |是阿里巴巴的一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。 地址：https://github.com/alibaba/dubbo 5.企业级流式计算引擎 JStorm JStorm 是参考 Apache Storm 实现的实时流式计算框架，在网络IO、线程模型、资源调度、可用性及稳定性上做了持续改进，已被越来越多企业使用。JStorm 可以看作是 storm 的 java 增强版本，除了内核用纯java实现外，还包括了thrift、python、facet ui。从架构上看，其本质是一个基于 zk 的分布式调度系统。 地址：https://github.com/alibaba/jstorm 6.apns4j apns4j 是 Apple Push Notification Service 的 Java 实现！ 地址：https://github.com/teaey/apns4j 7.分布式数据层 TDDL TDDL 是一个基于集中式配置的 jdbc datasource实现，具有主备，读写分离，动态数据库配置等功能。 地址：https://github.com/alibaba/tb_tddl 8.轻量级分布式数据访问层 CobarClient Cobar Client是一个轻量级分布式数据访问层（DAL）基于iBatis(已更名为MyBatis)和Spring框架实现。 地址：https://github.com/alibaba/cobarclient 9.淘宝定制 JVM：TaobaoJVM TaobaoJVM 基于 OpenJDK HotSpot VM，是国内第一个优化、定制且开源的服务器版Java虚拟机。目前已经在淘宝、天猫上线，全部替换了Oracle官方JVM版本，在性能，功能上都初步体现了它的价值。 地址：http://jvm.taobao.org 10.Java 图片处理类库 SimpleImage SimpleImage是阿里巴巴的一个Java图片处理的类库，可以实现图片缩略、水印等处理。 地址：https://github.com/alibaba/simpleimage 11.redis 的 java 客户端 Tedis Tedis 是另一个 redis 的 java 客户端。Tedis 的目标是打造一个可在生产环境直接使用的高可用 Redis 解决方案。 地址：https://github.com/justified/tedis 12.开源 Java 诊断工具 Arthas Arthas（阿尔萨斯）是阿里巴巴开源的 Java 诊断工具，深受开发者喜爱。 Arthas 采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。 地址：https://alibaba.github.io/arthas/ 13.动态服务发现、配置和服务管理平台 Nacos Nacos 致力于帮助您发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您实现动态服务发现、服务配置管理、服务及流量管理。 Nacos 帮助您更敏捷和容易地构建、交付和管理微服务平台。 Nacos 是构建以“服务”为中心的现代应用架构(例如微服务范式、云原生范式)的服务基础设施。 地址：https://nacos.io/en-us/ 14.Java 解析 Excel 工具 easyexcel Java 解析、生成 Excel 比较有名的框架有 Apache poi、jxl 。但他们都存在一个严重的问题就是非常的耗内存，poi 有一套 SAX 模式的 API 可以一定程度的解决一些内存溢出的问题，但 POI 还是有一些缺陷，比如 07 版 Excel 解压缩以及解压后存储都是在内存中完成的，内存消耗依然很大。easyexcel 重写了 poi 对 07 版 Excel 的解析，能够原本一个 3M 的 excel 用 POI sax 依然需要 100M 左右内存降低到 KB 级别，并且再大的 excel 不会出现内存溢出，03 版依赖 POI 的 sax 模式。在上层做了模型转换的封装，让使用者更加简单方便。 地址：https://github.com/alibaba/easyexcel 15.高可用流量管理框架 Sentinel Sentinel 是面向微服务的轻量级流量控制框架，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。 只要通过 Sentinel API 定义的代码，就是资源，能够被 Sentinel 保护起来。大部分情况下，可以使用方法签名，URL，甚至服务名称作为资源名来标示资源。 地址：https://github.com/alibaba/Sentinel 16.基于多维度 Metrics 的系统度量和监控中间件 SOFALookout Lookout 是一个利用多维度的 metrics 对目标系统进行度量和监控的项目。Lookout 的多维度 metrics 参考 Metrics 2.0 标准。Lookout 项目分为客户端部分与服务器端部分。 客户端是一个 Java 的类库，可以将它植入您的应用代码中采集 metrics 信息，客户端更多详情。 服务端代码部分，将于下一版本提供。通过 LOOKOUT 的服务，可以对 metrics 数据进行收集、加工、存储和查询等处理，另外结合 grafana，可做数据可视化展示。 地址：https://github.com/alipay/sofa-lookout 17.基于 Spring Boot 的研发框架 SOFABoot SOFABoot 是蚂蚁金服开源的基于 Spring Boot 的研发框架，它在 Spring Boot 的基础上，提供了诸如 Readiness Check，类隔离，日志空间隔离等等能力。在增强了 Spring Boot 的同时，SOFABoot 提供了让用户可以在 Spring Boot 中非常方便地使用 SOFAStack 相关中间件的能力。 地址：https://github.com/alipay/sofa-boot 18.轻量级 Java 类隔离容器 SOFAArk SOFAArk 是一款基于 Java 实现的轻量级类隔离容器，由蚂蚁金服公司开源贡献；主要为应用程序提供类隔离和依赖包隔离的能力；基于 Fat Jar 技术，应用可以被打包成一个自包含可运行的 Fat Jar，应用既可以是简单的单模块 Java 应用也可以是 Spring Boot 应用。可访问网址进入快速开始并获取更多详细信息。 地址：https://alipay.github.io/sofastack.github.io/ 19.分布式链路追踪中间件 SOFATracer SOFATracer 是一个用于分布式系统调用跟踪的组件，通过统一的 traceId 将调用链路中的各种网络调用情况以日志的方式记录下来，以达到透视化网络调用的目的。这些日志可用于故障的快速发现，服务治理等。 地址：https://github.com/alipay/sofa-tracer 20.高性能 Java RPC 框架 SOFARPC SOFARPC 是一个高可扩展性、高性能、生产级的 Java RPC 框架。在蚂蚁金服 SOFARPC 已经经历了十多年及五代版本的发展。SOFARPC 致力于简化应用之间的 RPC 调用，为应用提供方便透明、稳定高效的点对点远程服务调用方案。为了用户和开发者方便的进行功能扩展，SOFARPC 提供了丰富的模型抽象和可扩展接口，包括过滤器、路由、负载均衡等等。同时围绕 SOFARPC 框架及其周边组件提供丰富的微服务治理方案。 地址：https://github.com/alipay/sofa-rpc 21.基于 Netty 的网络通信框架 SOFABolt SOFABolt 是蚂蚁金融服务集团开发的一套基于 Netty 实现的网络通信框架。 为了让 Java 程序员能将更多的精力放在基于网络通信的业务逻辑实现上，而不是过多的纠结于网络底层 NIO 的实现以及处理难以调试的网络问题，Netty 应运而生。 为了让中间件开发者能将更多的精力放在产品功能特性实现上，而不是重复地一遍遍制造通信框架的轮子，SOFABolt 应运而生。 地址：https://github.com/alipay/sofa-bolt 22.动态非侵入 AOP 解决方案 JVM-Sandbox JVM-Sandbox，JVM 沙箱容器，一种基于 JVM 的非侵入式运行期 AOP 解决方案。 地址：https://github.com/alibaba/jvm-sandbox 23.面向云的分布式消息领域标准 OpenMessaging OpenMessaging 是由阿里巴巴发起，与雅虎、滴滴出行、Streamlio 公司共同参与创立，旨在创立厂商无关、平台无关的分布式消息及流处理领域的应用开发标准。 地址：https://github.com/openmessaging/openmessaging-java 24.P2P 文件分发系统 Dragonfly Dragonfly（蜻蜓）是阿里自研的 P2P 文件分发系统，用于解决大规模文件分发场景下分发耗时、成功率低、带宽浪费等难题。大幅提升发布部署、数据预热、大规模容器镜像分发等业务能力。 开源版的 Dragonfly 可用于 P2P 文件分发、容器镜像分发、局部限速、磁盘容量预检等。它支持多种容器技术，对容器本身无需做任何改造，镜像分发比 natvie 方式提速可高达 57 倍，Registry 网络出流量降低99.5%以上。 地址：https://github.com/alibaba/Dragonfly 25.LayoutManager 定制化布局方案 vlayout VirtualLayout是一个针对RecyclerView的LayoutManager扩展, 主要提供一整套布局方案和布局间的组件复用的问题。 地址：https://github.com/alibaba/vlayout 26.Java 代码规约扫描插件 P3C 项目包含三部分：PMD 实现、IntelliJ IDEA 插件、Eclipse 插件 地址：https://github.com/alibaba/p3c 作者：Java入门到入坟链接：https://www.jianshu.com/p/b560a912b4bf","tags":[{"name":"开源项目","slug":"开源项目","permalink":"http://yoursite.com/tags/开源项目/"}]},{"title":"如何超过大多数人","date":"2019-06-23T04:40:36.000Z","path":"2019/06/23/如何超过大多数人/如何超过大多数人/","text":"当你看到这篇文章的标题，你一定对这篇文章产生了巨大的兴趣，因为你的潜意识在告诉你，这是一本人生的“武林秘籍”，而且还是左耳朵写的，一定有干货满满，只要读完，一定可以练就神功并找到超过大多数人的快车道和捷径……然而…… 当你看到我这样开篇时，你一定会觉得我马上就要有个转折，告诉你这是不可能的，一切都需要付出和努力……然而，你错了，这篇文章还真就是一篇“秘籍”，只要你把这些“秘籍”用起来，你就一定可以超过大多数人。而且，这篇文章只有我这个“人生导师”可以写得好。毕竟，我的生命过到了十六进制2B的年纪，踏入这个社会已超过20年，舍我其谁呢？！ P.S. 这篇文章借鉴于《如何写出无法维护的代码》一文的风格……嘿嘿 相关技巧和最佳实践要超过别人其实还是比较简单的，尤其在今天的中国，更是简单。因为，你只看看中国的互联网，你就会发现，他们基本上全部都是在消费大众，让大众变得更为地愚蠢和傻瓜。所以，在今天的中国，你基本上不用做什么，只需要不使用中国互联网，你就很自然地超过大多数人了。当然，如果你还想跟他们彻底拉开，甩他们几个身位，把别人打到底层，下面的这些“技巧”你要多多了解一下。 在信息获取上，你要不断地向大众鼓吹下面的这些事： 让大家都用百度搜索引擎查找信息，订阅微信公众号或是到知乎上学习知识……要做到这一步，你就需要把“百度一下”挂在嘴边，然后要经常在群或朋友圈中转发微信公众号的文章，并且转发知乎里的各种“如何看待……”这样的文章，让他们爱上八卦，爱上转发，爱上碎片。 让大家到微博或是知识星球上粉一些大咖，密切关注他们的言论和动向……是的，告诉大家，大咖的任何想法一言一行都可以在微博、朋友圈或是知识星球上获得，让大家相信，你的成长和大咖的见闻和闲扯非常有关系，你跟牛人在一个圈子里你也会变牛。 把今日头条和抖音这样的APP推荐给大家……你只需要让你有朋友成功地安装这两个APP，他们就会花大量的时间在上面，而不能自拔，要让他们安装其实还是很容易的，你要不信你就装一个试玩一会看看（嘿嘿嘿）。 让大家热爱八卦，八卦并不一定是明星的八卦，还可以是你身边的人，比如，公司的同事，自己的同学，职场见闻，社会热点，争议话题，……这些东西总有一些东西会让人心态有很多微妙的变化，甚至花大量的时间去搜索和阅读大量的观点，以及花大量时间与人辩论争论，这个过程会让人上瘾，让人欲罢不能，然而这些事却和自己没有半毛钱关系。你要做的事就是转发其中一些SB或是很极端的观点，造成大家的一睦讨论后，就早早离场…… 利用爱国主义，让大家觉得不用学英文，不要出国，不要翻墙，咱们已经是强国了……这点其实还是很容易做到的，因为学习是比较逆人性的，所以，只要你鼓吹那些英文无用论，出国活得更惨，国家和民族都变得很强大，就算自己过得很底层，也有大国人民的感觉。然后，在知识学习和技能训练上，让他们不得要领并产生幻觉 让他们混淆认识和知识，以为开阔认知就是学习，让他们有学习和成长的幻觉……培养他们要学会使用碎片时间学习。等他们习惯利用碎片时间吃快餐后，他们就会失去精读一本书的耐性…… 不断地给他们各种各样“有价值的学习资料”，让他们抓不住重点，成为一个微信公众号或电子书“收藏家”…… 让他们看一些枯燥无味的基础知识和硬核知识，这样让他们只会用“死记硬背”的方式来学习，甚至直接让他们失去信心，直接放弃…… 玩具手枪是易用的，重武器是难以操控的，多给他们一些玩具，这样他们就会对玩具玩地得心应手，觉得玩玩具就是自己的专业…… 让他们喜欢直接得到答案的工作和学习方式，成为一个伸手党，从此学习再也不思考…… 告诉他们东西做出来就好了，不要追求做漂亮，做优雅，这样他们就会慢慢地变成劳动密集型…… 让他们觉得自己已经很努力了，剩下的就是运气，并说服他们去‘及时行乐’，然后再也找不到高阶和高效率学习的感觉…… 让他们觉得“读完书”、“读过书”就行了，不需要对书中的东西进行思考，进行总结，或是实践，只要囫囵吞枣尽快读完就等同于学好了……最后，在认知和格局上，彻底打垮他们，让他们变成韭菜。 让他们不要看到大的形势，只看到眼前的一亩三分地，做好一个井底之蛙。其实这很简单，比如，你不要让他们看到整个计算机互联网技术改变人类社会的趋势，你要多让他看到，从事这一行业的人有多苦逼，然后再说一下其它行业或职业有多好…… 宣扬一夜暴富以及快速挣钱的案例，最好让他们进入“赌博类”或是“传销类”的地方，比如：股市、数字货币……要让他们相信各种财富神话，相信他们就是那个幸运儿，他们也可以成为巴菲特，可以成为马云…… 告诉他们，一些看上去很难的事都是有捷径的，比如：21天就能学会机器学习，用区块链就能颠覆以及重构整个世界等等…… 多跟他们讲一些小人物的励志的故事，这样让他们相信，不需要学习高级知识，不需要掌握高级技能，只需要用低等的知识和低级的技能，再加上持续不断拼命重复现有的工作，终有一天就会成功…… 多让他们跟别人比较，人比人不会气死人，但是会让人变得浮躁，变得心急，变得焦虑，当一个人没有办法控制自己的情绪，没有办法让自己静下心来，人会失去耐性和坚持，开始好大喜欢功，开始装逼，开始歪门邪道剑走偏锋…… 让他们到体制内的一些非常稳定的地方工作，这样他们拥有不思进取、怕承担责任、害怕犯错、喜欢偷懒、得过且过的素质…… 让他们到体制外的那些喜欢拼命喜欢加班的地方工作，告诉他们爱拼才会赢，努力加班是一种福报，青春就是用来拼的，让他们喜欢上使蛮力的感觉…… 告诉他们你的行业太累太辛苦，干不到30岁。让他们早点转行，不要耽误人生和青春…… 当他们要做决定的时候，一定要让他们更多的关注自己会失去的东西，而不是会得到的东西。培养他们患得患失心态，让他们认识不到事物真正的价值，失去判断能力……（比如：让他们觉得跟对人拍领导的马屁忠于公司比自我的成长更有价值） 告诉他们，你现有的技能和知识不用更新，就能过好一辈子，新出来的东西没有生命力的……这样他们就会像我们再也不学习的父辈一样很快就会被时代所抛弃…… 每个人都喜欢在一些自己做不到的事上找理由，这种能力不教就会，比如，事情太多没有时间，因为工作上没有用到，等等，你要做的就是帮他们为他们做不到的事找各种非常合理的理由，比如：没事的，一切都是最好的安排；你得不到的那个事没什么意思；你没有面好主要原因是那个面试官问的问题都是可以上网查得到的知识，而不没有问到你真正的能力上；这些东西学了不用很快会忘了，等有了环境再学也不迟…… 最后友情提示一下，上述的这些“最佳实践”你要小心，是所谓，贩毒的人从来不吸毒，开赌场的人从来不赌博！所以，你要小心别自己也掉进去了！这就是“欲练神功，必先自宫”的道理。 相关原理和思维模型对于上面的这些技巧还有很多很多，你自己也可以发明或是找到很多。所以，我来讲讲这其中的一些原理。 一般来说，超过别人一般来说就是两个维度： 在认知、知识和技能上。这是一个人赖以立足社会的能力（参看《程序员的荒谬之言还是至理名言？》和《21天教你学会C++》） 在领导力上。所谓领导力就是你跑在别人前面，你得要有比别人更好的能力更高的标准（参看《技术人员发展之路》）首先，我们要明白，人的技能是从认识开始，然后通过学校、培训或是书本把“零碎的认知”转换成“系统的知识”，而有要把知识转换成技能，就需要训练和实践，这样才能完成从：认识 -&gt; 知识 -&gt; 技能 的转换。这个转换过程是需要耗费很多时间和精力的，而且其中还需要有强大的学习能力和动手能力，这条路径上有很多的“关卡”，每道关卡都会过滤掉一大部分人。比如：对于一些比较枯燥的硬核知识来说，90%的人基本上就倒下来，不是因为他们没有智商，而是他们没有耐心。 认知要在认知上超过别人，就要在下面几个方面上做足功夫： 1）信息渠道。试想如果别人的信息源没有你的好，那么，这些看不见信息源的人，只能接触得到二手信息甚至三手信息，只能获得被别人解读过的信息，这些信息被三传两递后必定会有错误和失真，甚至会被传递信息的中间人hack其中的信息（也就是“中间人攻击”），而这些找不出信息源的人，只能“被人喂养”，于是，他们最终会被困在信息的底层，永世不得翻身。（比如：学习C语言，放着原作者K&amp;R的不用，硬要用错误百出谭浩强的书，能有什么好呢？） 2）信息质量。信息质量主要表现在两个方面，一个是信息中的燥音，另一个是信息中的质量等级，我们都知道，在大数据处理中有一句名言，叫 garbage in garbage out，你天天看的都是垃圾，你的思想和认识也只有垃圾。所以，如果你的信息质量并不好的话，你的认知也不会好，而且你还要花大量的时间来进行有价值信息的挖掘和处理。 3）信息密度。优质的信息，密度一般都很大，因为这种信息会逼着你去干这么几件事，a）搜索并学习其关联的知识，b）沉思和反省，c）亲手去推理、验证和实践……一般来说，经验性的文章会比知识性的文章会更有这样的功效。比如，类似于像 Effiective C++/Java，设计模式，Unix编程艺术，算法导论等等这样的书就是属于这种密度很大的书，而像Netflix的官方blog和AWS CTO的blog等等地方也会经常有一些这样的文章。 知识要在知识上超过别人，你就需要在下面几个方面上做足功夫： 1）知识树（图）。任何知识，只在点上学习不够的，需要在面上学习，这叫系统地学习，这需要我们去总结并归纳知识树或知识图，一个知识面会有多个知识板块组成，一个板块又有各种知识点，一个知识点会导出另外的知识点，各种知识点又会交叉和依赖起来，学习就是要系统地学习整个知识树（图）。而我们都知道，对于一棵树来说，“根基”是非常重要的，所以，学好基础知识也是非常重要的，对于一个陌生的地方，有一份地图是非常重要的，没有地图的你只会乱窜，只会迷路、练路、走冤枉路！ 2）知识缘由。任何知识都是有缘由的，了解一个知识的来龙去脉和前世今生，会让你对这个知识有非常强的掌握，而不再只是靠记忆去学习。靠记忆去学习是一件非常糟糕的事。而对于一些操作性的知识（不需要了解由来的），我把其叫操作知识，就像一些函数库一样，这样的知识只要学会查文档就好了。能够知其然，知其所以然的人自然会比识知识到表皮的人段位要高很多。 3）方法套路。学习不是为了找到答案，而是找到方法。就像数学一样，你学的是方法，是解题思路，是套路，会用方程式解题的和不会用方程式解题的在解题效率上不可比较，而在微积分面前，其它的解题方法都变成了渣渣。你可以看到，掌握高级方法的人比别人的优势有多大，学习的目的就是为了掌握更为高级的方法和解题思路。 技能要在技能上超过别人，你就需要在下面几个方面做足功夫： 1）精益求精。如果你想拥有专业的技能，你要做不仅仅是拼命地重复一遍又一遍的训练，而是在每一次重复训练时你都要找到更好的方法，总结经验，让新的一遍能够更好，更漂亮，更有效率，否则，用相同的方法重复，那你只不过在搬砖罢了。 2）让自己犯错。犯错是有利于成长的，这是因为出错会让人反思，反思更好的方法，反思更完美的方案，总结教训，寻求更好更完美的过程，是技能升级的最好的方式。尤其是当你在出错后，被人鄙视，被人嘲笑后，你会有更大的动力提升自己，这样的动力才是进步的源动力。当然，千万不要同一个错误重复地犯！ 3）找高手切磋。下过棋，打个球的人都知道，你要想提升自己的技艺，你必需找高手切磋，在和高手切磋的过程中你会感受到高手的技能和方法，有时候你会情不自禁地哇地一下，我靠，还可以这么玩！ 领导力最后一个是领导力，要有领导力或是影响力这个事并不容易，这跟你的野心有多大，好胜心有多强 ，你愿意付出多少很有关系，因为一个人的领导力跟他的标准很有关系，因为有领导力的人的标准比绝大多数人都要高。 1）识别自己的特长和天赋。首先，每个人DNA都可能或多或少都会有一些比大多数人NB的东西（当然，也可能没有），如果你有了，那么在你过去的人生中就一定会表现出来了，就是那种大家遇到这个事会来请教你的寻求你帮助的现象。那种，别人要非常努力，而且毫不费劲的事。一旦你有了这样的特长或天赋，那你就要大力地扩大你的领先优势，千万不要进到那些会限制你优势的地方。你是一条鱼，你就一定要把别人拉到水里来玩，绝对不要去陆地上跟别人拼，不断地在自己的特长和天赋上扩大自己的领先优势，彻底一骑绝尘。 2）识别自己的兴趣和事业。没有天赋也没有问题，还有兴趣点，都说兴趣是最好的老师，当年，Linus就是在学校里对minx着迷了，于是整出个Linux来，这就是兴趣驱动出的东西，一般来说，兴趣驱动的事总是会比那些被动驱动的更好。但是，这里我想说明一下什么叫“真∙兴趣”，真正的兴趣不是那种三天热度的东西，而是那种，你愿意为之付出一辈子的事，是那种无论有多大困难有多难受你都要死磕的事，这才是“真∙兴趣”，这也就是你的“野心”和“好胜心”所在，其实上升到了你的事业。相信我，绝大多数人只有职业而没有事业的。 3）建立高级的习惯和方法。没有天赋没有野心，也还是可以跟别人拼习惯拼方法的，只要你有一些比较好的习惯和方法，那么你一样可以超过大多数人。对此，在习惯上你要做到比较大多数人更自律，更有计划性，更有目标性，比如，每年学习一门新的语言或技术，并可以参与相关的顶级开源项目，每个月训练一个类算法，掌握一种算法，每周阅读一篇英文论文，并把阅读笔记整理出来……自律的是非常可怕的。除此之外，你还需要在方法上超过别人，你需要满世界的找各种高级的方法，其中包括，思考的方法，学习的方法、时间管理的方法、沟通的方法这类软实力的，还有，解决问题的方法（trouble shooting 和 problem solving），设计的方法，工程的方法，代码的方法等等硬实力的，一开始照猫画虎，时间长了就可能会自己发明或推导新的方法。 4）勤奋努力执着坚持。如果上面三件事你都没有也没有能力，那还有最后一件事了，那就是勤奋努力了，就是所谓的“一万小时定律”了（参看《21天教你学会C++》中的十年学编程一节），我见过很多不聪明的人，悟性也不够（比如我就是一个），别人学一个东西，一个月就好了，而我需要1年甚至更长，但是很多东西都是死的，只要肯花时间就有一天你会搞懂的，耐不住我坚持十年二十年，聪明的人发明个飞机飞过去了，笨一点的人愚公移山也过得去，因为更多的人是懒人，我不用拼过聪明人，我只用拼过那些懒人就好了。 好了，就这么多，如果哪天你变得消极和不自信，你要来读读我的这篇文章，子曰：温故而知新。 （全文完）转载：https://coolshell.cn/articles/19464.html","tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"消息中间件使用场景","date":"2018-06-06T09:30:14.000Z","path":"2018/06/06/消息中间件使用场景/消息中间件使用场景/","text":"消息中间件出现的场景：BOSS中心和CRM中心存在不同的数据库，一些诸如停开机用户数据同步和缴费数据同步的过程以前老系统是使用应用集成平台扫描表做数据搬运的动作。搬运过程中对数据库的压力和IO的压力都很大，处理效率低并且对传输过程中丢失的数据无法追踪，无重试和保证机制。在这个需求下，将使用到同步的场景采用消息中间件来触发。 具体流程是：将需要同步的主题和数据从对象池中取出，没有的话就新建一个，但主题保证是已有的。通过NIO将消息主体等内容发送到消息中间件，并对数据做个存储（Mysql集群存，主备相互备份）数据库的建模按照一个主题来建表，队列分区建表有点浪费资源，消息中间件根据主题发送到相应的主机上去处理，如果因为任何原因失败了，将重试三次，三次后仍失败将消息状态置为失败。消息发送到相应主机后，存储到消息接口表中，根据进程扫描本地接口表做同步处理。处理成功后反馈给消息中间件，然后再发送消息给生产者告知。至此消息处理完毕。（ACK过程，第一次发送是SEND状态，第二次发送是COMMIT状态，全部状态都得到反馈，消息发送成功） 可以说说消息中间件使用的几点技术： 1.整体消息中间件系统参考这个是一个真实生产化的消息系统案例，由 1 个架构师 +2 个高级工程师设计开发，第一期研发测试到上生产约 3 个月，目前该系统日处理消息量过亿。假定公司因为业务需要，要构建一套分布式消息系统 MQ，类似 Kafka 这样的，这个问题看起来很大很复杂，但是如果你抽丝剥茧，透过现象看本质，Kafka 这样的消息系统本质上是下图这样的抽象概念： 队列其实就是类似数组一样的结构（用数组建模有个好处，有索引可以重复消费），里头存放消息 (Msg)，数组一头进消息，一头出消息； 左边是若干生产者 (Producer)，往队列里头发消息； 右边是若干消费者 (Consumer)，从队列里头消费消息； 对于生产者和消费者来说，他们不关心队列实现细节，所以给队列一个更抽象的名字，叫主题 (Topic)； 考虑到系统的扩容和分布式能力，一般一个主题由若干个队列组成，这些队列也叫分区 (Partition)，而且这些队列可能还是分布在不同机器上的，例如下图中 Topic A 的两个队列分布在 DataNode1 节点上，另外两个队列分布在 DataNode2 节点上，这样以后 Topic 可以按需扩容，DataNode 也可以按需增加。当然这些细节由 MQ 系统屏蔽，用户只关心主题，不关心底层实现。 单个数组队列的建模是整个 MQ 系统的关键，我们知道 Kafka 使用 append only file 建模队列，存取速度快。假设我们要存业务数据需要更高可靠性，也可以用数据库表来建模数组队列，如下图所示： 一个队列 (或者一个分区) 对应一张数据库表，表中的一个记录就是一条消息，表采用自增 id，相当于数组索引。这张表是 insert only 的，且 MySQL 会自动对自增 id 建优化索引，没有其它索引，所以插入和按 id 查找速度都非常快。下面是总体元数据模型： 一个主题 Topic 对应若干个队列 Queue 一个数据节点 DataNode 上可以住若干个队列 Queue 消费者 Consumer 和队列 Queue 之间是多对多关系，通过消费者偏移 Consumer Offset 进行关联 一个消费者组 Consumer Group 里头有若干个消费者 Consumer，它们共同消费同一个主题 Topic至此，我们对 MQ 的抽象建模工作完成，下面的工作是将这个模型映射到具体实现，经过分解，整个系统由若干个子模块组成，每个子模块实现后拼装起来的 MQ 总体架构如下图所示： Admin 模块管理数据库节点，生产者，消费者 (组)，主题，队列，消费偏移等元数据信息。 Broker 模块定期从 Admin 数据库同步元数据，接受生产者消息，按路由规则将消息存入对应的数据库表 (队列) 中；同时接受消费者请求，根据元数据从对应数据库表读取消息并发回消费者端。Broker 模块也接受消费者定期提交消费偏移。 Producer 接受应用发送消息请求，将消息发送到 Broker； Consumer 从 Broker 拉取消息，供上层应用进一步消费； 客户端和 Broker 之间走 Thrift over HTTP 协议，中间通过域名走 Nginx 代理转发； 这个设计 Broker 是无状态，易于扩展。架构思维总结：整个架构设计的思路体现了先总体抽象，再分解按模块抽象并实现，最后组合成完整的 MQ 系统，也就是 抽象 + 分治。这个 MQ 的实现工作量并不大，属于小型系统范畴，初期设计和开发由 1 个架构师 +2 个中高级工程师可以搞定。在初期研发和上生产之后，根据用户的不断反馈，系统设计经过多次优化和调整，符合三分架构、七分演化的 演化式架构 理念。目前该系统已经进入 V2 版本的架构和研发，其架构仍在持续演化当中，用户需求的多样性和对系统灵活性的更高要求，是系统架构演化的主要推动力。 2.具体几个使用关键技术a.首先是apache的commonpool2 Jar包 其实也是缓存IO的一种方式项目启动起来的时候，会static创建一个GenericKeyedObjectPool对象，然后将常用的ClientID放进去对象池初始化使用，方便后面服务调用时候每次发送前的处理。往对象池中塞对象GenericKeyedObjectPool（属于apache.commonpool2包中的接口），这个对象池技术运用的范围就很广了。比如Jedis框架中使用的对象池缓存技术就是依赖的commonpool2 Jar包去实现的。 几个概念：对象池(ObjectPool): 掌管对象的生命周期，获取，激活，验证，钝化，销毁等池对象(PooledObject): 池化对象，是需要放到ObjectPool对象的一个包装类。添加了一些附加的信息，比如说状态信息，创建时间，激活时间，关闭时间等池对象工厂(PooledObjectFactory): 用来创建池对象, 将不用的池对象进行钝化(passivateObject), 对要使用的池对象进行激活(activeObject), 对池对象进行验证(validateObject), 对有问题的池对象进行销毁(destroyObject)等工作 对象池化主要用于减少对象在创建和销毁上面的开销，如果是小对象则不需要池化，如果是大对象可以考虑池化，对于像数据库连接、网络之类的重对象来说是很有必要池化的，开发者自己根据需求判断，如果创建某种对象成为了影响程序性能的关键因素则需要池化。 关系图如下： ObjectPool1234567891011121314151617181920212223//从池中获取对象T borrowObject() throws Exception, NoSuchElementException, IllegalStateException;//将对象放回池中void returnObject(T obj) throws Exception;//废弃对象void invalidateObject(T obj) throws Exception;//添加对象void addObject() throws Exception, IllegalStateException, UnsupportedOperationException;//获取空闲对象个数int getNumIdle();//获取活跃对象个数int getNumActive();//清除池，池可用void clear() throws Exception, UnsupportedOperationException;//关闭池，池不可用void close(); PooledObject123456789101112131415161718192021222324252627282930313233343536//获得目标对象T getObject();long getCreateTime();long getActiveTimeMillis();long getIdleTimeMillis();long getLastBorrowTime();long getLastReturnTime();long getLastUsedTime();boolean startEvictionTest();boolean endEvictionTest(Deque&lt;PooledObject&lt;T&gt;&gt; idleQueue);boolean allocate();boolean deallocate();void invalidate();void setLogAbandoned(boolean logAbandoned);void use();void printStackTrace(PrintWriter writer);PooledObjectState getState();void markAbandoned();void markReturning(); PooledObjectFactory// 创建一个新对象;当对象池中的对象个数不足时,将会使用此方法来”输出”一个新的”对象”,并交付给对象池管理PooledObject makeObject() throws Exception; // 销毁对象,如果对象池中检测到某个”对象”idle的时间超时,或者操作者向对象池”归还对象”时检测到”对象”已经无效,那么此时将会导致”对象销毁”;// “销毁对象”的操作设计相差甚远,但是必须明确:当调用此方法时,”对象”的生命周期必须结束.如果object是线程,那么此时线程必须退出;// 如果object是socket操作,那么此时socket必须关闭;如果object是文件流操作,那么此时”数据flush”且正常关闭.void destroyObject(PooledObject p) throws Exception; // 检测对象是否”有效”;Pool中不能保存无效的”对象”,因此”后台检测线程”会周期性的检测Pool中”对象”的有效性,如果对象无效则会导致此对象从Pool中移除,并destroy;// 此外在调用者从Pool获取一个”对象”时,也会检测”对象”的有效性,确保不能讲”无效”的对象输出给调用者;// 当调用者使用完毕将”对象归还”到Pool时,仍然会检测对象的有效性.所谓有效性,就是此”对象”的状态是否符合预期,是否可以对调用者直接使用;// 如果对象是Socket,那么它的有效性就是socket的通道是否畅通/阻塞是否超时等.boolean validateObject(PooledObject p); // “激活”对象,当Pool中决定移除一个对象交付给调用者时额外的”激活”操作,比如可以在activateObject方法中”重置”参数列表让调用者使用时感觉像一个”新创建”的对象一样;如果object是一个线程,可以在”激活”操作中重置”线程中断标记”,或者让线程从阻塞中唤醒等;// 如果object是一个socket,那么可以在”激活操作”中刷新通道,或者对socket进行链接重建(假如socket意外关闭)等.void activateObject(PooledObject p) throws Exception; // “钝化”对象,当调用者”归还对象”时,Pool将会”钝化对象”；钝化的言外之意,就是此”对象”暂且需要”休息”一下.// 如果object是一个socket,那么可以passivateObject中清除buffer,将socket阻塞;如果object是一个线程,可以在”钝化”操作中将线程sleep或者将线程中的某个对象wait.需要注意的时,activateObject和passivateObject两个方法需要对应,避免死锁或者”对象”状态的混乱.void passivateObject(PooledObject p) throws Exception;` 实例class ConnectionTestFactory extends BaseKeyedPooledObjectFactory &#123; 12345678910111213141516171819202122232425262728293031323334 private static final Logger LOGGER = LoggerFactory.getLogger(ConnectionTestFactory.class); @Override public ConnectionTest create(String key) throws Exception &#123; return new ConnectionTest(key); &#125; @Override public PooledObject&lt;ConnectionTest&gt; wrap(ConnectionTest value) &#123; return new DefaultPooledObject&lt;&gt;(value); &#125; public static void main(String[] args) &#123; KeyedObjectPool&lt;String, ConnectionTest&gt; objectPool = new GenericKeyedObjectPool&lt;&gt;(new ConnectionTestFactory()); try &#123; //添加对象到池，重复的不会重复入池 objectPool.addObject(&quot;1&quot;); objectPool.addObject(&quot;2&quot;); objectPool.addObject(&quot;3&quot;); // 获得对应key的对象 ConnectionTest connectionTest1 = objectPool.borrowObject(&quot;1&quot;); LOGGER.info(&quot;borrowObject = &#123;&#125;&quot;, connectionTest1); // 释放对象 objectPool.returnObject(&quot;1&quot;, connectionTest1); //清除所有的对象 objectPool.clear(); &#125; catch (Exception e) &#123; LOGGER.error(&quot;&quot;, e); &#125; &#125;&#125; Config详解 lifo：连接池放池化对象方式，默认为truetrue：放在空闲队列最前面false：放在空闲队列最后面 fairness：等待线程拿空闲连接的方式，默认为falsetrue：相当于等待线程是在先进先出去拿空闲连接 maxWaitMillis：当连接池资源耗尽时，调用者最大阻塞的时间，超时将跑出异常。单位，毫秒数;默认为-1.表示永不超时. 默认值 -1maxWait：commons-pool1中 minEvictableIdleTimeMillis：连接空闲的最小时间，达到此值后空闲连接将可能会被移除。负值(-1)表示不移除；默认值1000L 60L 30L softMinEvictableIdleTimeMillis：连接空闲的最小时间，达到此值后空闲链接将会被移除，且保留“minIdle”个空闲连接数。负值(-1)表示不移除。默认值1000L 60L 30L numTestsPerEvictionRun：默认值 3 evictionPolicyClassName：默认值org.apache.commons.pool2.impl.DefaultEvictionPolicy testOnCreate：默认值false testOnBorrow：向调用者输出“链接”资源时，是否检测是有有效，如果无效则从连接池中移除，并尝试获取继续获取。默认为false。建议保持默认值. testOnReturn：默认值false testWhileIdle：向调用者输出“链接”对象时，是否检测它的空闲超时；默认为false。如果“链接”空闲超时，将会被移除；建议保持默认值。默认值false timeBetweenEvictionRunsMillis：“空闲链接”检测线程，检测的周期，毫秒数。如果为负值，表示不运行“检测线程”。默认值 -1L blockWhenExhausted：默认值true jmxEnabled：默认值true jmxNamePrefix：默认值 pool jmxNameBase：默认值 null maxTotal：链接池中最大连接数，默认值8commons-pool1 中maxActive改成maxTotal maxIdle：连接池中最大空闲的连接数,默认为8 minIdle: 连接池中最少空闲的连接数,默认为0 softMinEvictableIdleTimeMillis: 连接空闲的最小时间，达到此值后空闲链接将会被移除，且保留“minIdle”个空闲连接数。默认为-1. numTestsPerEvictionRun: 对于“空闲链接”检测线程而言，每次检测的链接资源的个数。默认为3. whenExhaustedAction: 当“连接池”中active数量达到阀值时，即“链接”资源耗尽时，连接池需要采取的手段, 默认为1：0：抛出异常1：阻塞，直到有可用链接资源2：强制创建新的链接资源 但是这里需要说明的是，对象池技术很容易成为系统IO的瓶颈。ObjectPool 常見的幾個 ObjectPool 實現性能都很差，反而很容易成為性能瓶頸。 Stormpot 性能強悍，不過存在偶爾死鎖的問題，而且作者也停止維護了。 HikariCP 性能不錯，不過其本身是一款數據庫連接池，用作 ObjectPool 並不稱手。我的建議是儘量避免使用 ObjectPool，轉而使用替代技術。更重要的是 Netty 的 Channel 是線程安全的，並不需要使用 ObjectPool 來管理。只需要一個簡單的容器來存儲 Channel，用的時候使用 負載均衡策略 選出一個 Channel 出來就行了。 framework thrpt (ops/us) ThreadLocal 685.418 Stormpot 272.934 HikariCP 139.126 SegmentLock 19.415 CommonsPool2 1.107 CommonsPool 0.276","tags":[{"name":"消息中间件","slug":"消息中间件","permalink":"http://yoursite.com/tags/消息中间件/"}]},{"title":"BOSS系统分布式架构","date":"2018-04-06T13:07:15.000Z","path":"2018/04/06/BOSS系统分布式架构/BOSS系统分布式架构/","text":"首先说下安徽移动系统BOSS系统的基本属性和移动系统中承担的所要职务整个移动系统中其实是分了很多中心的，BOSS（基本业务支撑）、CRM（客户关系处理）、订单中心（为了营业统计各种业务办理和缴费等比较重要操作的数据报表来源）、ESB（服务处理总线）等。其中就BOSS分为了三个子系统，账务处理、计费业务、账务管理。自己所在的部门也就是账务管理，处理移动各种账务关系的部门 比如BOSS比较重要的功能发票、缴费等都放在了我们部门上。 账务管理系统Java化和其他移动移动Java化所使用的架构模式是一致的系统基本的框架采用Spring和iBatis搭配使用，数据库使用Oracle延续之前C使用的数据库系统，在Java之前也做了很多调研使用MySQL、PostgreSQL这样的关系数据库，但是考虑到Java化项目比较紧急 数据库改用调研也就搁置了（其实本身想使用MySQL做分布式数据库的，但是考虑到老员工都比较熟悉Oracl也就推了又推）。在我看来使用MySQL是很好的选择，本身他对分布式就有很好的支持，几个库搭建分布式数据库可以缓轻很大来在缴费这一边的业务来源入库，还有每个月欠费预销这种业务对数据库IO的折磨。当然除了基本的Spring和iBatis还有很多公司自研的很多框架，基本上都是在开源项目上的增加业务。 然后说说整个移动系统的架构模式，基本的分布式RPC框架，因为前面也说了移动系统的子中心很多，跨中心这种交互就使用了业内很成熟的RPC框架模式，采用了Alibaba的Dubbo作为基础框架改写自有的一套框架。其实基础的核心都没有变，Netty作为网络通信，ZooKeeper作为注册中心来使用，要说改动了也就是中间加了很多自定义的Log功能和ESB服务缓存的功能。ESB这一块的注册服务缓存，都用的Oracle自家的Coherence缓存来实现的，对于这个缓存自己也不是很了解，只知道他在永久缓存上性能很突出，零时缓存就做的很不足。 —-To Be Continue（最近睡眠不足，等下再写）","tags":[{"name":"架构的一点点探索","slug":"架构的一点点探索","permalink":"http://yoursite.com/tags/架构的一点点探索/"}]},{"title":"HBase应用场景","date":"2018-03-29T03:28:17.000Z","path":"2018/03/29/HBase应用场景/HBase应用场景/","text":"最近在VPS上搭建HBase还没来的及总结，又忙着去看了看公司使用HBase的场景，所以在此做个总结顺带把HBase一些基本东西复习下 1、BOSS系统中处理详单数据时使用到了HBase数据库。因为计费处理话单文件是零散的、无序的、大存储量的。而且计费下发过来的文件是一种结构化的，固定形式的。所以如果需要持久化的话非常适合HBase这种分布式列数据库方式存储。查询语言对Java也有很好支持（除非与其他框架一起使用，如 Phoenix、Hive），不像关系数据库需要使用SQL语句。HBase的索引方式只支持Row-Key（除非和其他技术在一起用）, HBase的事务是单个Row级别的。而且像详单这种数据量增速很快的东西，使用传统关系数据库做拓展和扩容是非常困难的，往往建立在昂贵的硬件和性能优化上，HBase通过增加Region数量就可以达到此的效果。 Hive和HBase使用区别类似的有例如Hive这种数据库存储，但是Hive的场景适合统计一段时间内的数据，而且不能实时返回数据。例如，用来计算趋势或者网站的日志。Hive 不应该用来进行实时的查询（Hive 的设计目的，也不是支持实时的查询）。因为它需要很长时间才可以返回结果；HBase 则非常适合用来进行大数据的实时查询，例如 Facebook 用 HBase 进行消息和实时的分析。对于 Hive 和 HBase 的部署来说，也有一些区别，Hive 一般只要有 Hadoop 便可以工作。而 HBase 则还需要 Zookeeper 的帮助（Zookeeper，是一个用来进行分布式协调的服务，这些服务包括配置服务，维护元信息和命名空间服务）。再而，HBase 本身只提供了 Java 的 API 接口，并不直接支持 SQL 的语句查询，而 Hive 则可以直接使用 HQL（一种类 SQL 语言）。如果想要在 HBase 上使用 SQL，则需要联合使用 Apache Phonenix，或者联合使用 Hive 和 HBase。但是和上面提到的一样，如果集成使用 Hive 查询 HBase 的数据，则无法绕过 MapReduce，那么实时性还是有一定的损失。Phoenix 加 HBase 的组合则不经过 MapReduce 的框架，因此当使用 Phoneix 加 HBase 的组成，实时性上会优于 Hive 加 HBase 的组合，我们后续也会示例性介绍如何使用两者。最后我们再提下 Hive 和 HBase 所使用的存储层，默认情况下 Hive 和 HBase 的存储层都是 HDFS。但是 HBase 在一些特殊的情况下也可以直接使用本机的文件系统。例如 Ambari 中的 AMS 服务直接在本地文件系统上运行 HBase。 表 1. HBase 与 RDBMS 的区别 HBase RDBMS 硬件架构 类似于 Hadoop 的分布式集群，硬件成本低廉 传统的多核系统，硬件成本昂贵 容错性 由软件架构实现，由于由多个节点组成，所以不担心一点或几点宕机 一般需要额外硬件设备实现 HA 机制 数据库大小 PB GB、TB 数据排布方式 稀疏的、分布的多维的 Map 以行和列组织 数据类型 Bytes 丰富的数据类型 事物支持 ACID 只支持单个 Row 级别 全面的 ACID 支持，对 Row 和表 查询语言 只支持 Java API （除非与其他框架一起使用，如 Phoenix、Hive） SQL 索引 只支持 Row-key，除非与其他技术一起应用，如 Phoenix、Hive 支持 吞吐量 百万查询/每秒 数千查询/每秒 当然BOSS系统中也会保存2个月详单的数据放在物理数据库中作为备份，所以当BOSS系统使用大数据量查询时候，HBase配合HadHoop和ZooKeeper可以通过ZK来达到HA的效果，如果单纯将HBase作为单机部署其实发挥不了太大作用，搭配分布式部署起来可以发挥快速作用，ZK负责至少一个HBase Master可用，Hadoop则给Hbase提供HDFS作为存储基础，这样存取速度、容错性都有很好的保证。 2、BOSS系统在ROW-KEY上的设计a.首先Row-key的设计要保证唯一性，我们将手机号码倒置+时间戳和详单专业配置匹配，可以保证其唯一性。b.其次Row-key在保证唯一性前提下，还需要尽量缩小Row-key占用的字节数，这样可以提高搜索效率，缩小搜索范围。c.接着要考虑Row-key设计对访问热点和存储负载的尽量分散，比如说手机号码这一类从13开始就有很多号段很类似的，如果直接使用手机号码也可以达到唯一性，但是这样会让Row-key哈希后存储的很集中 随之访问热点也会很集中对于Region是很大的负担，也达不到应有的效率。但是倒置的话会让尽量分散开，保证了效率和负载。ex：put ‘sdetail_201704’,’05186155281 P20170418076652A60A742F2E’,’c1:d1’,’P|P11|PW|||18255168150|20170418|092802|551|LBMP20140228551.087|1O2000000000000000|02280928005890|1|1|000000||5515515101366|5515515101366|9000181003|5|0|100798024434565280|5|||||201704218000000|5|5|5|||$’ 就例如上面：05186155281 P20170418076652A60A742F2E 这种Row-key去设计 3、再说说BOSS Java化项目调用HBase的地方其实本身HBase已经提供了很好的对Java API的支持比如Get Scan这一类，但是为了保证业务逻辑的分离，公司计费方面负责详单数据处理，于是让计费侧做了接口我们来调用。 调用的方式就是很简单，和计费侧契约规定使用定长的TCP协议来接收返回数据，前1-2指定Column-key 或者 Qulifimer “DC”（在 Hbase 中，Row-key 加上 CF 加上 Qulifier 再加上一个时间戳才可以定位到一个单元格数据（Hbase 中每个单元格默认有 3 个时间戳的版本数据）），3-6指定消息体（没有HTTP这类消息头什么的，浪费IO），最后几位指定消息长度和是否结束标志（因为详单数据意味着很多，需要循环去取）。这样设计有点类似Dubbo的通信协议，删除无用信息，只保留业务信息和关键信息，提高IO效率。 然后计费侧根据我们的参数，做一些处理后Scan一定范围，这个范围根据手机号 和 时间就已经变得很小了，所以忽略了查询的时间，IO本身也没有太多无用信息，保证了BOSS查询特大数据量详单的效率。","tags":[{"name":"HBase","slug":"HBase","permalink":"http://yoursite.com/tags/HBase/"}]},{"title":"2017总结","date":"2018-03-10T01:45:14.000Z","path":"2018/03/10/2017总结/2017总结/","text":"2017真我2017年觉得时间过的很快，可能是更多时间投入到工作中了，也没在意每个月的更迭。所以也没什么时间来写文章了。 先说说自己的收获吧 去年给自己购了俩台服务器，一台Aliyun、一台VPS。Aliyun自然是部署自己玩的应用还有就是练习下以前零散学习的Linux操作，VPS不用说了，自然是部署个SS 看一看外面的世界，以前都是购买VPN，现在自己部署个洛杉矶机房的 速度还不错 很值有兴趣的朋友可以看看 购买选择看了很多论坛，放假回来就直接买了CN2 DC8的洛杉矶机房专线，具体参考可以看看搬瓦工的搬瓦工VPS-竞价比较高 搭建SSR搬瓦工对ssr搭建支持也非常棒，可以一键部署。这个网上教程很多，没什么可说的。其中需要注意一点的就是搭建好服务、本地客户端配置好之后，有可能无法正常Google、FQ。这个时候重启一下VPS或者SSR服务试一试。 SSH登录SSH远程登录VPS也是折腾VPS的基本需求之一。网上也有许多教程，Mac下SSH客户端我用的是iterm2，Windows平台下推荐的是Putty。其中需要注意的是登录密码不要搞错了，个人就是把VPS网页登录的密码当成远程登录VPS的密码，折腾了好久才发现。在VPS的控制台界面，左侧有一个root password modifiaction 选项，进了该页面即可获得远程登录SSH的随机密码。 SSH免密码登录每一次都输入密码，太难受了，当初Git也是SSH登录，自然有了免密码登录需求。很简单Google一下就有了相应的文章，这里推荐阮一峰老师的SSH原理与运用（一）：远程登录。很详细，跟着一步一步做就好了。 安装Python3.xLinux系统自带低版本的Python，比如Python2.6，但是不太好用，因此需要升级Python至3.x版本。注意是升级，不要删除老版本的Python，因为系统有许多东西依赖老版本的Python，相关需要安装的东西建议参考博文升级python2.7和安装pip,easy_install和setuptool。 尝试跑Python代码cd到根目录，建立project文件夹，里面就放置各种Python脚本即可。另外如果需要对Python版本有依赖的话，一定要用虚拟环境来管理。相关博文Kickstarting Flask on Ubuntu - Setup and Deployment.在上述博文中将学习到虚拟环境管理、Nginx配置、Supervisor配置、部署、GitHook、Automatic等内容。相信阅读完上述内容，你会有许多收获。 好了说完这些题外，这一年还是看了很多书的。看书使我开心😎 局外人一本书说尽了司法运作把人性摧残彻底的故事。总有人面对眼前一切都表现的毫不在乎，但这不是司法将他定罪的原因。加缪笔下的默尔索着力揭示了现代司法罗织罪状的邪恶。默尔索很干脆的承认自己犯了杀人命案，在面对人群社会与司法机制。感叹加缪23岁时 就能写出这样的故事。 容忍与自由看了胡适先生这么些个书，大多摘自他在《新青年》发表的文章以及他在北平和台湾个大学的演说，还有他在北大上课的笔记。胡适先生所推崇的思想无外乎: 读书这件事，要求实：进一寸有一寸的欢喜，每一步都踌躇满志才可以。自由解放，不是革命，而是由于自己 忠于自己。 我对胡适先生的印象就是，先生自己把西洋学习到的一套东西，真真切切的想融入到年轻人身上，再让年轻人自己去揣摩这些东西的作用。和孔子的“有教无类”有一些想法上的共鸣。所以说胡适先生 可以尊称为先生。 次贷危机书也就翻了一些自己感兴趣的章节跳着看，本身对金融也不是很了解，在当下国内次贷的泛滥，满屏的免评估小额贷款，学生和年轻人大多经不住这诱惑，最后带来的只能是失信和贷款冻结。只是说看了美国和日本的金融危机 历史总是遵循着轨迹发展的。 梵高·手稿书中记录了大量梵高画作的手稿和书信手稿。书信中不免看出当时梵高被一个镇的神父和大多数不理解他的人逼进疯人院的痛苦和失望。 创新公司·皮克斯启示作者就是皮克斯三位创始人之一埃德文·卡特姆写的。从他的角度描写皮克斯保持了这么久的活力是从哪里来的，包括和乔布斯共事的一些趣事和乔布斯一些理念是如何影响皮克斯到现在的。这本书我觉得每一个有创业梦想的人或者说正在创业的人都应该看的。埃德文·卡特姆说了很多皮克斯艰难时期是如何度过的，从迪斯尼不看好电脑动画制作，到迪斯尼愿意提供最好的剧本与皮克斯合作，这期间他所经历的一切，都是值得品读的。 算法图解算法的知识本身自己没有仔细研究过，翻了几页算法导论也是看的头疼。我是个喜欢图形记忆和了解的人，所以对这种抽象图形化的东西 接受还是很快的。作者用Python演示算法，又能深入了解算法，又能练习Python 何乐不为。 还有很多书就不想列举了，总之看书使我快乐一定觉得我这一年肯定没好好学习，不不。。。计算机类的书太贵了，我真的不舍得。。。所以都下了电子书版本来看，平时工作中需要看哪一类，也方便一些。比如推荐给大家： 《Java性能权威指南》 《快学Scala(中文完整版)》 《HBase权威指南中文版》 《恰如其分的软件架构.风险驱动的设计方法》 《奇点临近》 《分布式服务框架原理与实践_李林锋著》 《Java TCP/IP Socket编程》 《Python Cookbook》 《高性能网站建设指南》 《Groovy_in_Action》 《Java 8 In Action》 《数据结构与算法分析_Java语言描述·Mark Allen Weiss》…有点多，也不一一列举了，上面这些书是主要看了，有些书可以当成字典 用的时候去查看，效果更好。有些书要当成个镜子，每天照一照。比如推荐的系列就是 in_Action系列，和图灵系列，这些系列的书从作者到出版社审核都是很优秀的，看个技术类的书 如果内容质量不高，你看的都是过时的 活着说是错的，就很尴尬了。 经过这一年看技术的发展，谈谈自己的感想： 首先是Java发展太快了，从Lambda到模块化再到马上要出来的Version10的类型自动推断，需要关注的点很多。有总比没有强，有了这些东西的支撑，你在选择使用Java来实现的时候 才有更多选择。 今年TOBO社区显示 明显大家将关注点放在了支持动态的语言上面比如Scala、Python等这些灵活的语言上面。因为前些年JavaScript以及衍生出来的语言发展迅速，后端语言上也需要跟上脚步。所以新的一年可以多关注一些支持动态的语言上面。 当当当，Github上AI开源的东西，要看 要看 要看。前些日子拿了Facebook开源预测框架prophet试试手，这种时序预测的框架其实有很大作用，在预测房价上。。。哦不是预测价格走势、航班晚点趋势等等 商业用途上有很大优势，因为只需要一个csv文件横轴竖轴的数据就可以预测，很方便。看开源代码也可以学习算法。 最后是自己对行业和发展的想法，计算机语言发展的快速大家都知道，你现在学习的东西 10年以后可能根本用不到，这也不是什么危言耸听。所以思忖着把学习重点可以适当放在架构这一类学习周期时间长，更迭速度慢的东西上 会发挥更大作用。至于框架类的东西，精通几个优秀框架即可，没必要因为招聘上写了一大堆框架熟悉优先，你就去学习所有框架，没这个必要 和 没这个精力，大多可以做到使用API就很不错了。 新年还是要有计划的，多学习 多买彩票。。。（缺钱啊）嗯 多培养自己其他领域的爱好，工作不忙了（不可能的）去重新拿上吉他给自己放松 钓鱼和朋友小聚一下 篮球和撸铁要继续（不然就是药不能停的状态了） 看书也不能停 非技术相关的使劲买买买（技术的就下载电子书） 收集几大主机，玩游戏也很重要 把媳妇骗回家 想学架子鼓 想学木匠技艺（这个怎么说呢。。。房子装修的时候自己给自己做家具吧。。。） 继续保持好奇心「Stay hungry. Stay foolish.」 Less is More 好了，最重要的就是一句话 Less is More还是送上我最喜欢的","tags":[{"name":"2017随笔","slug":"2017随笔","permalink":"http://yoursite.com/tags/2017随笔/"}]},{"title":"Love","date":"2017-05-07T14:10:26.000Z","path":"2017/05/07/love/love/","text":"在住的地方蜗居不久，以为跳槽到现在的公司会轻松很多，没想到以来就是遇上大版本改造中间件。身体有点吃不消。也许久没有回家了。每周末都定期和父母通话，尤其母亲很是想念。所以今天父母今天也是开车来到住所看望我，前一晚告诉父母没啥带的，不用麻烦了。但还是带了一大包零食和席子,真的很谢谢他们对我的爱","tags":[{"name":"2017随笔","slug":"2017随笔","permalink":"http://yoursite.com/tags/2017随笔/"}]},{"title":"为了所爱的体育","date":"2017-03-06T13:31:53.000Z","path":"2017/03/06/forsoccer/forsoccer/","text":"&emsp;&emsp;刚刚看完了每周一必看的节目《天下足球》😁&emsp;&emsp;好吧，其实我只是个伪足球迷，我对足球的热爱完完全全来自那荒度时光（美好时光）的PES8，实况足球国际版。我滴孩，这游戏在零几年还能再火点吗。电脑上，PlayStation上，Xbox上。我都忘了当时有没有Xbox可以玩。反正只要是各个平台上有上线的，实况足球，FIFA，我都要玩个遍。 &emsp;&emsp;记得那时几个哥哥都没成家，过年就是我们的狂欢，那必然少不了去网吧，去游戏厅。我的大哥是最喜欢足球的，所以足球游戏他是不会错过的。每次我们都会玩个很久的PES实况足球。他喜欢AC米兰和皇马，我就是曼联和巴塞罗那。如果是国家队，那他一定是意大利，我就一定是英格兰。反正每次都是我赢😎所以无所谓什么队。 &emsp;&emsp;所以说对足球的喜爱，或者说是对足球的认识，完全是从游戏开始的。但渐渐也喜欢上了足球，不愧是世界第一运动。还记得第一次看足球赛是中国队进入世界杯决赛圈，我的天哪，那时候住在爷爷家。爷爷家客厅的大沙发，放下来就是个床，中国队的比赛基本上夜夜都要熬夜看，家里也不乏和我一样有好几个伪球迷，但是当时的中国队真的可以说是梦之队。像郝海东，李铁这样的球员，现在的中国队真的是差了一大截，但是总的来说，中国队在积极组建和成长中，这是好事。虽然我最喜欢的运动是篮球，而且基本上到现在都保持着每周一次的频率去践行自己喜欢的运动。但是足球真的可以说是我所爱的运动。场上胜利11人的队伍，为了同一个目标在绿荫上奔跑真的可以说是个伟大的运动。💪🏿比起篮球的观赏性，足球更多的是代表了一种精神。这也是我最喜欢的。 &emsp;&emsp;所以说你不看足球，你不知道有些人定义了足球中的一些动作。你不知道罗纳尔多的钟摆过人，你不知道齐达内的马赛回旋，你不知道小罗的牛尾巴，你不知道禁区旁有个皮耶罗区域，你不知道巴蒂式进球，你不知道班克斯式扑救，你不知道克鲁伊夫转身，你不知道勺子点球，你不知道蝎子摆尾，你不知道彩虹过人和蛙跳过人，你不知道贝式弧线，你也不知道有炸丸子和内切射门。","tags":[{"name":"我热爱的","slug":"我热爱的","permalink":"http://yoursite.com/tags/我热爱的/"}]},{"title":"新公司","date":"2017-02-24T14:15:52.000Z","path":"2017/02/24/newstart/newstart/","text":"离开 &emsp;&emsp;离开了上家公司，自己也是在Research&amp;Develop这个岗位上摸爬滚打了快一年了，从以前搞黑盒到现在的研发，总觉得自己做了不得了的决定。记得在YOHO！的时候，特别希望经理教我白盒和自动化，经理来句，你TM年纪轻轻的，学什么测试，搞开发啊。我一想 是啊，搞什么测试，去学开发去。 &emsp;&emsp;然后跟着我那程序设计老师，去做了个项目，类似今日头条App的后端和后台管理系统，那些日子真是难熬啊。天天买各种书看，几乎每天都要通宵，自己身体也受不住了，还好做完了，也上线了，自己也充实了一把，所以也把这个难熬的事情想成愉悦的经历了。起码我从一个Java初学，学习了数据库，学习了Web相关的知识Servlet‘html’css这些基本，再到传说中的几大框架实现个基本功能。也算是有点入门了，当时自己一个人做出这个后端，还是挺有成就感的，虽然现在看到老的代码觉得逻辑很奇怪，但这些都不是事😅 &emsp;&emsp;后来又来到一个不大不小的外包单位，发现还是自己一个人来负责后端，轻车熟路一般又学习到了Mybatis持久框架，也是自己一个人默默在问，在学习。更宝贵的经验是，我学习到了很多关于整个项目流程的知识，因为后端是我一人负责，开发‘部署’测试的调度也就落到我头上了。虽然当时没接触过，但我还是对经理来了一句么问题。然后自己又从网上下了很多Linux的电子书和Junit的电子书，学会了在Linux环境下自己发布部署，自己去单元测试代码。项目中也用到了很多第三方集成，像极光推送‘即时IM这样的，学习了一些第三方集成的基本知识。学习JSTL‘Bootstrap’Jquery去做更方便的后台管理系统。知道了用Ajax调用接口是多么的方便。也自己去实现了一个短信验证码的功能，从平台调取发送短信，然后保存到数据库中，传Token到App端去双向验证会更安全。这段时间自己负责了很多东西，也学到了很多东西，身边有一群贵人和好同事的帮忙，自己也很开心。 &emsp;&emsp;再后来就来到了上家公司，也接近毕业了🎓，所以说还是很想努力去💪做出一些事情的。来到这里才发现你不仅要明白技术很重要，在一个项目中，去了解业务矩阵也是非常重要的事情，你应该明白参与项目的具体全部业务，也应该明白这个项目或者说这个系统在整个公司中是承担什么职责，是原子的还是复合的，需不需要与外部系统做交互，应该用什么方式去交互，你的每一个功能实现，是不是和大家讨论过实现的方式，以及功能的实现是不是可以有分支或者策略模式去拓展的。你都要考虑。这是非常重要的，也是我在这个公司学到的最宝贵经验。还记得16年元旦给自己定了一个计划。 &emsp;&emsp;当时觉得这计划得流产，毕竟觉得有些多了。没想到就在16年底，除了第一个还都基本完成了。😎公司在新的项目中就是使用了SpringJDBCTemplet+Spring+SpringMVC去实现的，SpringJDBCTemplet以下简称JT，而且是我自己封装了数据访问层，用反射和代理把JT去封装实现了。每次操作都使用这个Jar包去实现数据访问。domin也都封装到Jar中去，让domin更纯洁。也省去了JT很多必须要实现的东西，比如Rower这些东西。自己也成就感很大，毕竟公司都用上了自己封装的东西。 来到&emsp;&emsp;年后，因为各种原因，来到了一家国企上班。怎么说呢，新到一家国企上班。最大的感悟就是，好TM严肃啊。不能上外网，不能用U盘，这让习惯懒散的我不能适应。然后这也是刚来几天的不习惯，发现也是很多的，国企的技术并不是多么落后迂腐，反而和我想的不一样，是非常先进的。有调度中心，有自己开发的中间件（目前在这个部门下），也有很多RPC的应用，有一大推自己封装的相当不错的框架，连构建都用Jenkins，觉得逼格可以啊。 所以说新公司！努力吧少年！","tags":[{"name":"2017随笔","slug":"2017随笔","permalink":"http://yoursite.com/tags/2017随笔/"}]},{"title":"First Page","date":"2017-01-08T17:21:15.000Z","path":"2017/01/09/FirstPage/","text":"欢迎来到Hexo的世界，Fanta","tags":[]}]