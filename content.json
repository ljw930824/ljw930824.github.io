[{"title":"开发流程改造的探索","date":"2021-01-05T05:59:48.000Z","path":"2021/01/05/开发流程改造的探索/开发流程改造的探索/","text":"开发和部署前准备流程 开发流程指北 codereview（http://192.168.205.11:12312/ydjc-cloud）时候，无论是否是需求实际开发人员。请参与到开发流程中来，换位自己是开发人员来考虑需求实现的可行性和负债率。这样大家会一起进步 技术的实际选型，每个人参与进来。理想的情况下，每人预想一下实际可能用到的技术，大家在会议室讨论实现的可行性和利弊，通过会议记录敲定所有的选型 根据自己开发的情况，每天提交代码前检查下提交代码sonar、ali插件扫描情况，酌情修改。依赖的检查可以放到最少每周进行一次 部署流程指北 需求开发负责人上线前准备checklist，以保证上线检查效率 需求开发人准备部署文档发送给参与项目每个人，检查如果不了解系统的情况下能否看懂 预生产环境搭建，至少要保证提供的升级包的正确性。时间充裕情况下可以保证模拟环境测试 意见建议请编辑在此，我们定期查阅 相关的文章 页面: 开发流程改造的探索","tags":[{"name":"开发流程指北","slug":"开发流程指北","permalink":"https://fantalovelife.club/tags/%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B%E6%8C%87%E5%8C%97/"}]},{"title":"Springboot2.3.4版本后Spring Security 5.2.x. 不支持Authorization Server","date":"2021-01-05T05:43:48.000Z","path":"2021/01/05/Springboot2-3-4版本后Spring-Security-5-2-x-不支持Authorization-Server/Springboot2-3-4版本后Spring-Security-5-2-x-不支持Authorization-Server/","text":"1. 前言在使用 OAuth2.0 中 Authorization Server （授权服务器）是一个回避不了的设施，在大多数情况下我们调用的是一些知名的、可靠的、可信任的第三方平台，比如 QQ、微信、微博、github 等。我们的应用只作为 Client 进行注册接入即可。也就是说我们只需要实现 OAuth2.0 客户端的逻辑就可以了，无须关心授权服务器的实现。然而有时候我们依然希望构建自己的 Authorization Server。我们应该如何实现？今天不会讨论具体的技术细节，来谈谈 OAuth2.0 的技术选型。 2. Spring Security OAuth2 现状在做 Spring Security 相关教程 的时候首先会考虑 Spring 提供的 OAuth2.0 功能。当我去 Spring 官网了解相关的类库时发现居然 Spring 的 OAuth2.0 类库即将过期的通知，有图有真相： ![](/images/Spring2.3.4不支持Spring Auth Server/Spring不支持Auth Server.png) 总结以下就是 Spring Security OAuth 的模块即将过期，后续的功能已经迁移到 Spring Security 5.2.x 中，但是不会再提供 Authorization Server 的功能。 在官方声明中还提到， 当前 Spring Security OAuth 分支是 2.3.x 和 2.4.x。2.3.x版本将于 2020 年 3 月寿命终止。我们将在达到功能均等后至少一年支持 2.4.x 版本。因此鼓励用户开始将其旧版 OAuth 2.0 客户端和资源服务器应用程序迁移到Spring Security 5.2 中的新支持。详细参见 官方博客. 3. 对 OAuth2.0 的技术选型从上面的信息看来， Spring Security 未来依然提供 OAuth2 的 客户端支持 和 资源服务器支持。授权服务器 将逐渐退出 Spring Security 的生态环境。所以如果没有授权服务器需求的情况下选择 Spring Security 依然是没有问题的，一旦有这个需求我们该如何选择？我这里调研了几个开源免费的项目。 3.1 keycloakkeycloak是 RedHat 公司出品。是一个致力于解决应用和服务身份验证与访问管理的开源工具。可以通过简单的配置达到保护应用和服务的目的。它提供了身份和访问管理的有用功能： 单点登录（SSO），身份代理和第三方登录。 支持 OpenID Connect，OAuth 2.0 和 SAML 2.0 等标准协议。 用户集中管理。 客户端适配器，轻松保护应用程序和服务。 可视化管理控制台和帐户管理控制台。 可扩展性、高性能、快速实现落地。 文档比较完毕，而且是一个成熟的、免费的商业级产品。 3.2 Nimbus SDK全称是 Nimbus OAuth 2.0 / OpenID Connect SDK，这是一个类库。Spring 官方在博客中提到可以使用该类库构建 Authorization Server，它同时支持 OAuth2.0 和 OpenID Connect，比较完整地实现了这两个协议，而且针对补充协议也在积极的跟进。缺点在于中文教程不多而且是一个类库性质的。不过官方提供了 DEMO ，有能力的同学入门也不算难事。 3.3 Apache OltuApache Oltu 是 Apache 基金会旗下的一个毕业项目。提供了 OAuth2.0 的常用实现，根据文档提供的信息来看上手还是比较简单的，模块化的提供了对 Authorization Server、Resource Server、Client、JOSE、 的支持。中文教程网上还是有不少的，缺点在于项目维护比较滞后，最新的版本是 2016 年发布的。 3.4 Vertx-auth-oauth2vertx-auth-oauth2 属于 Vert.x 生态，提供了比较完整的 OAuth2.0 实现，而且项目维护比较活跃，唯一的缺点在于有技术栈的局限性。","tags":[{"name":"Spring Securit 5.2.x 不支持Authorization Server","slug":"Spring-Securit-5-2-x-不支持Authorization-Server","permalink":"https://fantalovelife.club/tags/Spring-Securit-5-2-x-%E4%B8%8D%E6%94%AF%E6%8C%81Authorization-Server/"}]},{"title":"小程序-快应用-AppClips","date":"2021-01-05T05:26:30.000Z","path":"2021/01/05/小程序-快应用-AppClips/小程序-快应用-AppClips/","text":"小程序-快应用-App Clips对比 小程序 快应用 App Clips 运行方式 启动方式 💔 进入提供方App 💔 进入提供方App ♥️ 即时启动 桌面启动 💔 Android only 💔 Android only ✅ 通知启动 ✅ ✅ ✅ 二维码启动 ✅ ✅ ✅ NFC启动 ❌ ❌ ✅ 地理围栏启动 ❌ ✅ ✅ 生态 跨平台 ✅ ❌ ❌ 代码形式 DSL DSL Native 包体积 平台限制* 平台限制* 10MB 整合形式 第三方Apps 第三方Apps 自带Apps 开发工具 ♥️ 流行IDE* ♥️ 流行IDE* 💔 Xcode 审核机制 平台方审核 平台方审核 苹果审核 体验 流畅度* 一般 高 高 首次下载 ♥️ 快 ♥️ 快 💔 慢 二次加载 一般 ♥️ 快 ♥️ 快 完整App安装 💔 跳转安装 💔 跳转安装 ♥️ 一键安装 平台能力 支付 内置平台方 内置平台方，微信，支付宝 内置Apple Pay 帐户体系 内置平台方 内置平台方 内置Apple ID登录 数据同步 ♥️ 平台方及开发商提供 ♥️ 平台方及开发商提供 💔 无iCloud支持 健康数据 ♥️ 授权后可用 ♥️ 授权后可用 💔 不支持 业务能力 ♥️ 平台方内置 ♥️ 平台方内置 💔 需要集成平台方SDK 流畅度 取决于代码实现方式，这里采用标准方式进行对比 小程序开发工具 平台方流行IDE插件准备中 平台包体积限制 “- 支付宝：整个小程序所有分包大小不超过4MB - 微信：整个小程序所有分包大小不超过16MB，单个分包不超过2MB - 快应用：1MB - 苹果App Clip：10MB” Created by @janlay","tags":[{"name":"小应用对比","slug":"小应用对比","permalink":"https://fantalovelife.club/tags/%E5%B0%8F%E5%BA%94%E7%94%A8%E5%AF%B9%E6%AF%94/"}]},{"title":"基于图的大规模微服务Trace分析方法与企业实践（转载）","date":"2021-01-05T03:44:24.000Z","path":"2021/01/05/基于图的大规模微服务Trace分析方法与企业实践/基于图的大规模微服务Trace分析方法与企业实践(转载)/","text":"基于图的大规模微服务Trace分析方法与企业实践","tags":[{"name":"好文转载","slug":"好文转载","permalink":"https://fantalovelife.club/tags/%E5%A5%BD%E6%96%87%E8%BD%AC%E8%BD%BD/"}]},{"title":"Chrome的DevTools","date":"2021-01-05T03:35:55.000Z","path":"2021/01/05/Chrome的DevTools/Chrome的DevTools/","text":"&nbsp;&nbsp;现在去看 Google Devtools，会发现已经多了很多有意思的内容，比如下图一中的 FP、FCP、FMP、Layout Shift 等，事实上，Google 从 19 年开始已经提倡开发者去优化用户体验指标而不是技术硬指标，那可以通过哪些指标去衡量用户体验指数呢？梳理了下，如下图，内容实现相当丰富的。 &nbsp;&nbsp;对于日常构建我们的Web，像Chrome的DevTools以及Lighthouse都是有很大的指导性优化意义，可以关注此方面的 善用这些浏览器工具","tags":[{"name":"奇淫巧技","slug":"奇淫巧技","permalink":"https://fantalovelife.club/tags/%E5%A5%87%E6%B7%AB%E5%B7%A7%E6%8A%80/"}]},{"title":"关于M1芯片","date":"2021-01-05T03:27:08.000Z","path":"2021/01/05/关于M1芯片/关于M1芯片/","text":"Apple的M1芯片可能会给你的多线程序带来一些bug，因为ARM芯片不像X86的芯片会保证内存访问顺的一致性。 （当然，如果高级语方处理了则不会有问题） 有两篇文章可以读一下： 1）强弱内存模型的CPU https://preshing.com/20120930/weak-vs-strong-memory-models/ 2）在弱内存模型的CPU上的内存访问乱序的问题 https://preshing.com/20121019/this-is-why-they-call-it-a-weakly-ordered-cpu/","tags":[{"name":"M1芯片","slug":"M1芯片","permalink":"https://fantalovelife.club/tags/M1%E8%8A%AF%E7%89%87/"}]},{"title":"关于美国大选的问题","date":"2021-01-05T03:01:37.000Z","path":"2021/01/05/关于美国大选的问题/关于美国大选的问题/","text":"前段时间看了几个美国总统选举地图的前端实现，基本上都是用svg的方式，fox news的还是做的很帅的。美帝媒体的前端技术还是很不错的。 我截图给大家看下 他们都有一个共性，就是都是用SVG来构造自适应图表展示 关于SVG可以看更专业的介绍 链接：https://juejin.im/post/6844903593212903431","tags":[{"name":"前端","slug":"前端","permalink":"https://fantalovelife.club/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"20年软件开发趋势的20种预测","date":"2020-03-05T06:52:50.000Z","path":"2020/03/05/20 Predictions about Software Development trends in 2020/20 Predictions about Software Development trends in 2020/","text":"开发趋势预测 Cloud, Container, Programming, Database, Deep Learning, Software Architecture, Web, App, Batch, Streaming, Data Lake, ByteCode, No Code Md KamaruzzamanFollow Dec 11, 2019 · 20 min read Photo by h heyerlein on Unsplash In only a few weeks, 2019 will end and we will welcome the new year 2020. For the Software Development industry, 2019 was a great year as Software and Digitalisation are affecting every sector. The trend will continue and will impact the world even more in 2020. Predicting the future is difficult. Predicting the future of Software Development is even more challenging and risky. I don’t own any Crystal Ball. But I can use my “Human Learning” to make predictions about Software Development trends in 2020. I will predict the most important stacks of Software Development: from Cloud to the ByteCode. 1. Infrastructure: All roads lead to Cloud Photo by Patrick Tomasso on Unsplash 2019 was a great year for Cloud vendors. Not only the startups are using the cloud but also conservative and security concern companies like Government Organizations, Health Care, Mining, Banks, Insurances and even Pentagon are moving towards the cloud. The trend will continue in 2020 also where companies of all sizes and types will move or at least plan to move in Cloud. Gartner recently published the following figures for 2020: Source: Gartner So, if you are a decision-maker still pondering about moving towards the cloud, maybe you should rethink your strategy. If you are an individual developer and still have not tried your hands in the cloud, 2020 will be a perfect time to give a try. Most of the big Cloud providers (Amazon, Microsoft, Google) offer free credits to give hands-on experience in the cloud. Google is the most generous in this respect: it offers 300 USD free credit for one year. Google Cloud Free Tier 2. Cloud: AWS is awesome but others will catch upAs a first cloud provider, Amazon AWS ruled 2019. With the widest portfolio of services, Amazon AWS will continue to rule in 2020 as well. As Canalys has published the Q3, 2019 figures: the Big Cloud providers (AWS, Azure, GCP) hold a 56% market share whereas AWS alone holds 32.6% market share: Source: Canalys But other Cloud providers are also planning aggressively to close the gap with AWS. Microsoft has specifically targeted large enterprises. Recently Microsoft has pipped Amazon and got the 10 Billion USD deal from Pentagon for its cloud Project “JEDI”. This deal can boost Azure reputation and similarly dent the armor of AWS: Source: Marketwatch Google is driving the Cloud Native Computation Foundation to standardize Cloud operations. Google’s long-term goal is to make Cloud migration easier so that companies can later move from AWS to GCP. IBM has recently bought RedHat with a whopping 36 billion to have a share in the Cloud market: Source: TechCrunch 2020 will see a lot more acquisition and merging. Also, many startups will come with new ideas and innovations e.g. Multi-Cloud services. From the neck-to-neck fight of the cloud vendors, companies can only profit from reduced prices and more innovations. 3. Containerization: Kubernetes will be CoolerIn the container orchestration field, once there was a fight between Kubernetes, Docker Swarm, and Mesos. Kubernetes has emerged as the clear winner from the fight and only grows stronger. Cloud is a Distributed Systems and Kubernetes is it Operating Systems (Distributed Linux). In Kubecon + CloudNativeCon North America 2019, 12000 attendees have taken part which is a 50% growth compared to the same event in 2018. Here is the exponential growth of Kubecon + CloudNativeCon in the last four years: Source: CNCF/Linux Foundation There is no slowing down of Kubernetes in near future and it will only become stronger in 2020. You can make your safe bet on Kubernetes in 2020 as the Backbone of the Cloud Native movement. Just a side note, Docker Enterprise is recently sold to Mirantis with an undisclosed amount: Source: Migrantis Only a few years ago, it was all about Docker but now it is all about Kubernetes. Docker failed to monetize in its heydays and tried to gain money a few years later when the industry has already moved away. Another example that timing is everything in the modern tech world. 4. Software Architecture: Microservices will be MainstreamIn the Software Architecture paradigm, the shift towards Microservice Architecture continued in 2019 as shown by Google Trends: [Google](https://trends.google.com/trends/explore?cat=5&amp;date=today 5-y&amp;q=%2Fm%2F011spz0k) Trends: Microservices As the industry moves towards Cloud in 2020 and beyond, the Microservices Architecture will be more dominant. One of the main reasons for the rise of Microservice Architecture is that it fits perfectly with Cloud Native, fast software development. In a previous Blog post, I explained the basic principle of Microservice Architecture and its advantages/disadvantages: Microservice Architecture: A brief overview and why you should use it in your next projectBackground for Microservice Architecture and advantages of Microservice Architecture over Monolithic Architecturetowardsdatascience.com I assume there will also be a trend to go back to Monolithic Software Architecture as for many use cases, Microservice Architecture is overkill and designing Microservice Architecture is challenging. What are the best practices to design Microservice Architecture? I have written a summary in a blog post previously, which may be helpful: Effective Microservices: 10 Best Practices10 Tips to implement Microservice Architecture the right waytowardsdatascience.com 5. Programming(overall): Python will eat the world Photo by Sharon McCutcheon on Unsplash Be it Machine Learning, Data Analytics, Data Processing, Web Development, Enterprise Software Development or taking the photo of Blackhole: Python is everywhere. Also, popular programming language ranking site TIOBE ranked Python as the third most popular programming language behind Java and C : Source: TIOBE What is even more interesting is that the popularity of Python has doubled in 2019 (from 5% to 10%). I know that there are many limitations and flaws in the TIOBE index, but it is the most widely accepted ranking of programming language. I have written an article where I have listed top 10 in-demand programming languages and Python tops the chart: Top 10 In-Demand programming languages to learn in 2020In-depth analysis and ranking of the top programming languages for job seekers and new developersmedium.com The rise of Python will continue in 2020 and it will close the gap with Java and C. The other omnipresent programming language JavaScript is facing a downward trend (JavaScript fatigue?). Why Python has seen such an upsurge? It has lowered the barriers to entry into programming, has an excellent community and beloved by the data scientists and new generation developers. 6. Programming (Enterprise): Java and JVM will reign By 22Kartika — Java Island, Source: Wikipedia As shown by the TIOBE index in the previous paragraph, Java is still the most dominant programming language on the planet and will be dominant in 2020. Java’s runtime, JVM is one of the best pieces of software engineering and offers a solid foundation for Java. Many popular languages like Kotlin, Scala, Clojure, Groovy use JVM as their runtime. Recently, Oracle has changed the license for JVM: Source: Infoworld The change of license means all companies who will use Java, Kotlin, Scala or any other JVM languages will be affected and need to pay whopping subscription fees. Fortunately, there is the OpenJDK initiative which will still keep the JVM free of cost. Several companies will provide Enterprise support for JVM: Source: Java Code Geeks Because of its “Cargo Ship” like size and speed, JVM languages are not best fit in today’s Serverless computing. Oracle is driving the “GraalVM” initiative to make Java nimble, fast and better fit in the Serverless world. As there is no other alternative to Java that offers Enterprise-grade stability and trust, it will continue to rule in 2020 and beyond. 7. Java Enterprise: Spring is here Source: spring.io Once upon a time, there was a huge competition between the Spring Framework and Java Enterprise Edition (JavaEE) in the Enterprise software development. But Oracle has given a walkover in the competition by being inactive in JavaEE. That triggered the formation of the “Micro Profile” initiative and eventually the formation of JakartaEE where Oracle has open-sourced its Java EE source code. While all the politics and movements were happening surrounding JavaEE, Spring Framework has won the JVM Enterprise framework war with very active development and quick to react with the changing environment e.g. Cloud-Native support. In 2020 also, the Spring framework will be the no. 1 framework in the JVM ecosystem. Two very attractive projects are under development to make Java smaller and nimbler so that Java would be a good choice for Serverless computation. One framework is Micronaut: Source: Micronaut The other framework is Quarkus: Source: Quarkus Both Micronaut and Quarkus are targeting to use GraalVM and will attract the Java community even more in 2020. 8. Programming: Rust, Swift, Kotlin, TypeScript will make the breakthroughIn the 2000s, there was a stagnation in the programming language landscape. Most people thought there is no need for a new programming language as Java, C, C++, JavaScript, and Python were fulfilling all the needs. Google has opened the door of new programming languages by creating Go. In the last decade, many interesting programming languages appeared like Rust, Swift, Kotlin, TypeScript. One reason for this development is that existing Programming languages are often not capable of taking the advantages of the latest changes in Hardware (e.g. Multi-Core, faster Network, Cloud). Another factor is that modern languages especially focus on developer Ergonomics i.e. faster and easier development. In Stackoverflow developer survey, most of the modern languages take the top position (Rust takes the first place for 4 consecutive years): Source: Stackoverflow In another Blog post, I have discussed in depth why it is worth learning the modern programming languages like Rust, Go, Kotlin, TypeScript, Swift, Julia, Dart and how they offer better alternative to existing programming languages: Top 7 Modern programming language to learn nowHow Rust, Go, Kotlin, TypeScript, Swift, Dart, Julia can boost your career and improve your software development skillmedium.com Recently, Microsoft announced that they are exploring heavily the Rust programming to develop secure software as shown below: Source: Techbeacon Also, Amazon has recently declared that they are sponsoring Rust: Source: Techbeacon The Programming language Kotlin also emerges as the main competitor of Java in the JVM world with Google declaring official support for Kotlin in Android: Source: Android Angular supports TypeScript as the main programming language instead of using vanilla JavaScript. Other JavaScript frameworks, e.g. React and Vue also started to offer more support for TypeScript. The trend will continue in 2020 and many other Giant companies that are probably having a deeper look in Close door in the new generation programming languages like Rust, Swift, TypeScript, Kotlin will come forward and declare their support openly. 9. Web: JavaScript will continue to dominate Photo by Pankaj Patel on Unsplash Once upon a time, JavaScript was not a strong enough programming language and Frontend was mainly developed using Backend frameworks like JSF, Ruby on Rails, Django, Laravel and rendered from the Server. The situation has changed forever once AngularJS hit the scene in 2014. Since then, many more JavaScript Web frameworks emerged (Angular 2+, React, Vue.js, Meteor.js) and JavaScript is the mainstream Web development framework now. With lots of innovation is going on in JavaScript frameworks and with the rise of Microservice Architecture, JavaScript frameworks will dominate the Frontend development even more in 2020 10. JavaScript Web Framework: React RocksAlthough it came after AngularJS, React has the biggest impact on Web Development in the last decade and saved Facebook in its fight with Google+. React brought some fresh and innovative ideas in Frontend development e.g. Event Sourcing, Virtual Dom, One-way data binding, Component-based development and many more. It impacted the community in such gravity that Google discarded AngularJS and completely rewritten Angular2+ by borrowing ideas from React. React is by far the most dominant and stable JavaScript Web Framework as shown below from the NPM download stats: Source: npm trends Recently, Facebook has announced the React-Fiber project to completely rewrite the React core algorithm for better Concurrency and user experience: Source: Github In 2020 also, React should be your go-to Web Framework for new projects. In another post, I have given an in-depth analysis of JavaScript front-end frameworks and React come out as the number one: Top 5 In-Demand JavaScript Frameworks for Front-End Development in 2020In-depth analysis and ranking of the top JavaScript frameworks for Front-end developers, job seekers and for…medium.com What about other Frontend Web Frameworks e.g. Angular (Angular2+) and Vue? Angular is also a solid Web Development framework especially suited for Enterprises. I am sure that Google will invest heavily in Angular in the coming years. Vue is another very popular Web Framework which is backed by Community and several Giant Chinese Corporations. If you are already using either Angular or Vue, no need to migrate to React in 2020. 11. App Development: Native for Enterprises Photo by Rodion Kutsaev on Unsplash In the Mobile App Development, the Hype around Hybrid App Development or Cross Platform Native App Development has slowed down a bit. Hybrid App Development/Cross Platform Native App Development gives faster development velocity as you need only one team instead of two. But the Native app gives better user experience and better performance. Also in Hybrid/Cross-Platform App Development, the App always needs to be tweaked to have advanced features. For Enterprises, Native App Development is still the preferred solution and the trend will continue in 2020. Airbnb has published a detailed Blog post why they have ditched the leading Hybrid App Development Platform “React Native”: Sunsetting React NativeDue to a variety of technical and organizational issues, we will be sunsetting React Native and putting all of our…medium.com Although Facebook is trying to improve React Native and Google is pushing hard its own App Development Platform Flutter, they are mainly suited for Prototype, POC, MVP or feature light apps whereas Native App Development will continue its reign in 2020. One interesting fact among the Native App Development is that Google is promoting Kotlin and Apple is promoting Swift as the main programming languages because of the developer-friendly and modern features of the languages. Google has recently reiterated its support for Kotlin, which is good news for Kotlin adopters: Source: Phoronix 12. Hybrid/Cross-Platform App Development: React NativeThere are many use cases where the Hybrid/Cross-Platform App is a pragmatic option. In this area, there are many options: the already existing Xamarin, Ionic and the newer React Native, Flutter. Facebook has built React Native based on the highly successful and mature Web framework React. Like its Web counterpart, React Native is also the dominant framework in Hybrid/Cross-Platform App development as shown below: Source: Google Trends As React Native and React share the same base, they offer high Code re-usability and offer the option: “Write once, Run Everywhere”. Another added advantage of using React Native (or other Facebook Framework) is that Facebook uses React Native to develop its own Mobile App. Google is late in this domain but has gained significant traction in last year with its own Cross-Platform Native App framework Flutter. Flutter offers better performance but needed another not yet mainstream Programming language Dart. React Native will continue to dominate in this field also in 2020 considering all the changes happening in the React Ecosystem. 13. API: REST for peace Image by S. Hermann &amp; F. Richter from Pixabay REST is like the 800-pound Gorilla in the API domain. It is the de facto and most widely used technique in the API based communication between services. There are also some other options in this field. As you may have correctly guessed if you have read this article carefully until this point: gRPC from Google and GraphQL from Facebook. Both of them are interesting technology but offer different capabilities. Google has developed gRPC as a reincarnation of the Remote Procedure Calls techniques (e.g. SOAP) but on Steroid. It uses Protobuf instead of JSON as the messaging format. On the other side, Facebook has developed GraphQL as an aggregation layer to avoid the chatty and frequent REST calls. Both gRPC and GraphQL have gained success and excel where they fit. In 2020 also, REST will be the most dominant API whereas GraphQL and gRPC will be used as a complementary technique. 14. Artificial Intelligence: Tensorflow 2.0 will dominate Image by Gerd Altmann from Pixabay In the Deep Learning/Neural Network domain also, Google and Facebook are the main players. Google has given us TensorFlow which is based on a popular Deep Learning framework Theano. It quickly became the main library for Deep Learning/Neural Network computation. Google has even delivered a specially designed GPU (TPU) to speed up the computation of TensorFlow. Facebook is not far behind in the Deep Learning field, as they probably have the biggest collection of images and videos. Facebook has delivered a Deep Learning library PyTorch which is based on another popular Deep Learning library Torch. There is a subtle difference in the way both the framework works. TensorFlow uses Static Graph for its computation whereas PyTorch uses Dynamic Graph for its computation. The advantage of using a dynamic graph is that it can correct itself on the fly. Also, PyTorch is more Python friendly, which is the main programming language in Data Science. As PyTorch was gaining more and more popularity, Google has released TensorFlow 2.0 in October 2019 which uses the dynamic graph and more Python friendly: Source: TensorFlow In 2020, TensorFlow 2 and PyTorch will fight neck to neck. Considering the larger community of TensorFlow, I assume that TensorFlow 2 will be the dominant library for Deep Learning. 15. Database: SQL Supreme but Distributed SQL will be the Holy GrailDuring the Hype days of NoSQL, many people were laughing at SQL and pointing its limitations. Many posts were explaining how NoSQL is much better and will replace the SQL. But once the Hype was over, people soon realized that the world cannot live without SQL databases. Here are the rankings of the most popular databases: Source: DB Engines As we can see from the above chart, the SQL databases hold the top 4 spots. The reason SQL is dominant is that it offers durable ACID transnational guarantees, which are the most essential requirements for the business applications. The NoSQL databases offer horizontal scaling but with the price of compromising the ACID guarantee. The Web-scale companies are looking for the “Master Database” i.e. a Database which will offer an ACID guarantee like SQL databases and will offer horizontal scaling like NoSQL database. At this moment, two solutions partially fulfill the requirements of “Master Database”: Amazon’s Aurora and Google’s Spanner. Aurora offers almost all SQL features but no horizontal write scaling, whereas Spanner offers horizontal write scaling but does not support many SQL features**.** In 2020, the two databases will hopefully come closer or someone else will come up with a “Distributed SQL”. If that happens, he will probably get a Turing prize. 16. Data Lake: MinIO will rise to prominence Photo by Tom Gainor on Unsplash As discussed in the previous section, the modern Data Platform is complex. Companies usually have OLTP databases (SQL) to support ACID transactions and OLAP databases (NoSQL) for analytical purposes. Also, Enterprises have other kinds of data storage e.g. for Search (Solr, Elastic Search) or Computations (Apache Spark). Companies build their data platform based on Data Lake i.e. Data is copied from OLTP databases to Data Lake. All other types of Data Applications (e.g. OLAP, Search) use the Data Lake as their Golden Source. Hadoop Distributed File System (HDFS) was the de facto Data Lake until Amazon came with Object Storage S3. Scalable and Cheap, S3 soon became the de facto Data Lake in many companies. The only problem is that using S3 binds the Data Platform tightly with Amazon AWS Cloud. Although Microsoft Azure has Blob Storage and Google has similar Object storage, they are not compatible with AWS S3. A new Open Source, S3 compatible Object Storage MinIO could be the rescue for many companies. With Enterprise-grade support and built for Cloud-Native environment, MinIO offers Cloud Neutral Data Lake: Source: MinIO Microsoft has recently announced MinIO in Azure Marketplace with the slogan: “providing Amazon S3 API compatible data access for Azure Blob Storage services”. If Google GCP and others also offer MinIO, then it could be a great step forward to facilitate Multi-Cloud. 17. Big Data Computation: Spark will continue to sparkle Image by Gerd Altmann from Pixabay In modern days, Enterprises usually need to run a computation on their large-scale dataset, which needs Distributed Batch Job. Hadoop Map-Reduce was the first Distributed Batch computation platform. Recently, Apache Spark has taken the place of Hadoop as the king of Batch Processing. How Apache Spark can give better performance than Hadoop? I have written a blog post previously to have an in-depth analysis of the Modern-day Data Platform: Programming language that rules the Data Intensive (Big Data+Fast Data) frameworks.A brief overview of Big Data frameworkstowardsdatascience.com Spark has specifically targeted the limitations of Hadoop Map-Reduce i.e. processing everything in Memory instead of saving the Data in storage after every costly operation. Although Spark uses the CPU and Memory hungry JVM for Batch processing, it will rule the Batch processing framework in 2020 and beyond. I wish someone will develop a more efficient Batch processing framework using Rust, which could replace Spark and save the huge Cloud bill of the companies. 18. Big Data Streaming: Flink for the future Photo by Hendrik Cornelissen on Unsplash A few years ago, real-time stream processing was not possible. Usually, a micro Batching framework like Spark Streaming was used which has given “near” Real-time Stream processing. However, Apache Flink changed the landscape by offering a real-time stream processing capability. Until 2019, Apache Flink could not gain enough Traction as it could not compete with Spark’s marketing. The table has turned once the Chinese Tech Giant Alibaba bought Data Artisan (the company behind Apache Flink) in January 2019: Source: TechCrunch Flink should be the number one option if a company wants to process real-time stream processing in 2020 and beyond. Although Flink also suffers the same way as Spark by using the CPU hungry and heavyweight JVM and handing over a large Cloud bill to its users. 19. ByteCode: WebAssembly will see mass adoption Photo by Mārtiņš Zemlickis on Unsplash I came to know about WebAssembly after reading about it from an interview from Brandon Eich, the creator of JavaScript. Modern JavaScript (after es5) is an excellent programming language. But like any other language, it has limitations. The biggest limitation of JavaScript is that it is slow as JavaScript Engine needs to read, parse and process the JavaScript textual “Abstract Syntax Tree”. Another problem with JavaScript is that it is Single-Threaded and cannot take advantage of modern hardware (e.g. Multi-Core, GPU). As a result, many computation-intensive applications (e.g. Games, 3-D graphics) cannot run on the browser. Several companies (led by Mozilla) developed the WebAssembly, the low-Level Byte code format for the Browser, to run any supported Programming language in Web. The MVP of WebAssembly is released which supports near Metal programming language (e.g. C++, Rust): Source: WebAssembly WebAssembly has enabled computation-intensive applications like Games and Autocad to run on Browser. The goal of WebAssembly is even bigger and to run outside the browser as well. WebAssembly also offers inherently the Security and Sandboxing due it its Web support. It also means that WebAssembly can be used in the following “Outside the Browser” scenarios: Hybrid native apps on mobile devices. Serverless Computations with no Cold start problem (Cloud) Server-side computation of untrusted code (CDN) In my prediction, 2020 could be a breakthrough year for WebAssembly and many giant corporations (including the Cloud Vendors) and community will embrace it. 20. Coding: Low-Code/No-Code will gain momentum Source: pixabay The rapid digitalization and Industry 4.0 revolution means that there is a huge gap in Supply-Demand for Software Developers. As a result, many people or companies cannot implement their ideas because of a lack of Developers. To lower the barrier the entries into Software Development, there is an attempt to make Software Development with no Code (No Code) or with Minimal Code (Low Code). This effort is known as LCNC (Low-Code No-Code) and has gained some success in 2019: Source: no code The goal of this movement is that anyone can develop software if he/she has a cool idea with no coding experience. Although I am still skeptical about using the LCNC frameworks in production, they can lay the foundation for others. Companies like Amazon, Google can build a solid product on this foundation (the same way AWS Lambda flourishes on the foundation of Google App Engine). It is worth to have a look at the LCNC movement which will get more traction in 2020. If you found this helpful, please share it on your favorite forums (Twitter, Facebook, LinkedIn). Comments and constructive criticisms are highly appreciated. Thanks for reading! 转载自： https://towardsdatascience.com/20-predictions-about-software-development-trends-in-2020-afb8b110d9a0","tags":[{"name":"20 Predictions","slug":"20-Predictions","permalink":"https://fantalovelife.club/tags/20-Predictions/"}]},{"title":"Chrome开启多线程下载","date":"2020-01-13T15:01:36.000Z","path":"2020/01/13/Chrome开启多线程下载/Chrome开启多线程下载/","text":"开启多线程下载很简单 首先Chrome浏览器地址栏中输入chrome://flags/ 然后搜索 Parallel downloading 开启Enable后重启即可，速度提升还是很明显的","tags":[{"name":"奇淫巧技","slug":"奇淫巧技","permalink":"https://fantalovelife.club/tags/%E5%A5%87%E6%B7%AB%E5%B7%A7%E6%8A%80/"}]},{"title":"SpringCloudGateWay使用ReactiveRedis","date":"2019-07-31T15:06:37.000Z","path":"2019/07/31/SpringCloudGateWay使用Redis/SpringCloudGateWay使用Redis/","text":"最近在使用SpringCloudGataWay搭建一个路由项目，想着用Reids做一层缓存，而且也想图省事直接使用springcloud自带的限流器，它的限流器很简单就是基于redis实现的令牌桶模式 很方便但可怕的事发生了，他居然用的ReactiveRedis也就是异步实现的一套redis东西，和我们常用的data-redis和jedis这些东西完全不兼容也就是这个东西 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis-reactive&lt;/artifactId&gt; &lt;/dependency&gt; 本质上它是实现一套异步非阻塞交互的东西，很好用 就是有点难理解，项目中还有很多需要用到Redis的地方，学习成本和可靠性是我需要考虑的。所以我只需要限流器使用现成的就可以了，其他的我还是需要按照传统redis的方式去处理，发现他除了网络方面有改写其他和redis很像，于是写了一段RedisConfig。。。果然就是各种报错。发现除了template返回很多异步的处理，连连接工厂也换成了lettuce这当然是要各种报错了。于是查了下lettuce，可以兼容处理成只需要连接的改变即可。 ```java@Configurationpublic class RedisConfig { @Value(“${spring.redis.database}”) private int database; @Value(&quot;$&#123;spring.redis.host&#125;&quot;) private String host; @Value(&quot;$&#123;spring.redis.password:#&#123;null&#125;&#125;&quot;) private String password; @Value(&quot;$&#123;spring.redis.port&#125;&quot;) private int port; @Value(&quot;$&#123;spring.redis.timeout&#125;&quot;) private long timeout; @Value(&quot;$&#123;spring.redis.lettuce.pool.max-idle&#125;&quot;) private int maxIdle; @Value(&quot;$&#123;spring.redis.lettuce.pool.min-idle&#125;&quot;) private int minIdle; @Value(&quot;$&#123;spring.redis.lettuce.pool.max-active&#125;&quot;) private int maxActive; @Value(&quot;$&#123;spring.redis.lettuce.pool.max-wait&#125;&quot;) private long maxWait; /** * 缓存有效期 */ private Duration entryTtl = Duration.ofHours(24L); /** * 连接超时 */ private Duration connectTimeout = Duration.ofSeconds(15L); /** * 读取超时 */ private Duration readTimeout = Duration.ofSeconds(30L); @Bean LettuceConnectionFactory lettuceConnectionFactory(GenericObjectPoolConfig genericObjectPoolConfig) &#123; // 单机版配置 RedisStandaloneConfiguration redisStandaloneConfiguration = new RedisStandaloneConfiguration(); redisStandaloneConfiguration.setDatabase(database); redisStandaloneConfiguration.setHostName(host); redisStandaloneConfiguration.setPort(port); redisStandaloneConfiguration.setPassword(RedisPassword.of(password)); // 集群版配置 // RedisClusterConfiguration redisClusterConfiguration = new RedisClusterConfiguration();// String[] serverArray = clusterNodes.split(“,”);// Set nodes = new HashSet();// for (String ipPort : serverArray) {// String[] ipAndPort = ipPort.split(“:”);// nodes.add(new RedisNode(ipAndPort[0].trim(), Integer.valueOf(ipAndPort[1])));// }// redisClusterConfiguration.setPassword(RedisPassword.of(password));// redisClusterConfiguration.setClusterNodes(nodes);// redisClusterConfiguration.setMaxRedirects(maxRedirects); LettuceClientConfiguration clientConfig = LettucePoolingClientConfiguration.builder() .commandTimeout(Duration.ofMillis(timeout)) .poolConfig(genericObjectPoolConfig) .build(); LettuceConnectionFactory factory = new LettuceConnectionFactory(redisStandaloneConfiguration, clientConfig); return factory; &#125; /** * GenericObjectPoolConfig 连接池配置 * * @return */ @Bean public GenericObjectPoolConfig genericObjectPoolConfig() &#123; GenericObjectPoolConfig genericObjectPoolConfig = new GenericObjectPoolConfig(); genericObjectPoolConfig.setMaxIdle(maxIdle); genericObjectPoolConfig.setMinIdle(minIdle); genericObjectPoolConfig.setMaxTotal(maxActive); genericObjectPoolConfig.setMaxWaitMillis(maxWait); return genericObjectPoolConfig; &#125; /** * 实例化 RedisTemplate 对象 * * @return */ @Bean public RedisTemplate&lt;String, Object&gt; functionDomainRedisTemplate() &#123; RedisTemplate&lt;String, Object&gt; redisTemplate = new RedisTemplate&lt;&gt;(); initDomainRedisTemplate(redisTemplate, lettuceConnectionFactory(genericObjectPoolConfig())); return redisTemplate; &#125; /** * 设置数据存入 redis 的序列化方式 * * @param redisTemplate * @param factory */ private void initDomainRedisTemplate(RedisTemplate&lt;String, Object&gt; redisTemplate, RedisConnectionFactory factory) &#123; redisTemplate.setKeySerializer(new StringRedisSerializer()); redisTemplate.setValueSerializer(new KryoRedisSerializer&lt;&gt;(Object.class)); redisTemplate.setHashKeySerializer(new StringRedisSerializer()); redisTemplate.setHashValueSerializer(new KryoRedisSerializer&lt;&gt;(Object.class)); ParserConfig.getGlobalInstance().setAutoTypeSupport(true); redisTemplate.setConnectionFactory(factory); &#125; /** * 实例化 HashOperations 对象,可以使用 Hash 类型操作 * * @param redisTemplate * @return */ @Bean public HashOperations&lt;String, String, Object&gt; hashOperations(RedisTemplate&lt;String, Object&gt; redisTemplate) &#123; return redisTemplate.opsForHash(); &#125; /** * 实例化 ValueOperations 对象,可以使用 String 操作 * * @param redisTemplate * @return */ @Bean public ValueOperations&lt;String, Object&gt; valueOperations(RedisTemplate&lt;String, Object&gt; redisTemplate) &#123; return redisTemplate.opsForValue(); &#125; /** * 实例化 ListOperations 对象,可以使用 List 操作 * * @param redisTemplate * @return */ @Bean public ListOperations&lt;String, Object&gt; listOperations(RedisTemplate&lt;String, Object&gt; redisTemplate) &#123; return redisTemplate.opsForList(); &#125; /** * 实例化 SetOperations 对象,可以使用 Set 操作 * * @param redisTemplate * @return */ @Bean public SetOperations&lt;String, Object&gt; setOperations(RedisTemplate&lt;String, Object&gt; redisTemplate) &#123; return redisTemplate.opsForSet(); &#125; /** * 实例化 ZSetOperations 对象,可以使用 ZSet 操作 * * @param redisTemplate * @return */ @Bean public ZSetOperations&lt;String, Object&gt; zSetOperations(RedisTemplate&lt;String, Object&gt; redisTemplate) &#123; return redisTemplate.opsForZSet(); &#125; }​```","tags":[{"name":"SpringCloudGateWay","slug":"SpringCloudGateWay","permalink":"https://fantalovelife.club/tags/SpringCloudGateWay/"}]},{"title":"阿里巴巴Java开源项目","date":"2019-06-25T16:38:11.000Z","path":"2019/06/26/阿里巴巴Java开源项目/阿里巴巴Java开源项目/","text":"1.分布式应用服务开发的一站式解决方案 Spring Cloud Alibaba Spring Cloud Alibaba 致力于提供分布式应用服务开发的一站式解决方案。此项目包含开发分布式应用服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。 依托 Spring Cloud Alibaba，您只需要添加一些注解和少量配置，就可以将 Spring Cloud 应用接入阿里分布式应用解决方案，通过阿里中间件来迅速搭建分布式应用系统。 地址：https://github.com/spring-cloud-incubator/spring-cloud-alibaba 2.JDBC 连接池、监控组件 Druid Druid是一个 JDBC 组件。 1.监控数据库访问性能。 2.提供了一个高效、功能强大、可扩展性好的数据库连接池。 3.数据库密码加密。 4.SQL执行日志。 地址：https://github.com/alibaba/druid 3.Java 的 JSON 处理器 fastjson fastjson 是一个性能很好的 Java 语言实现的 JSON 解析器和生成器，来自阿里巴巴的工程师开发。 主要特点：快速FAST (比其它任何基于Java的解析器和生成器更快，包括jackson）；强大（支持普通JDK类包括任意Java Bean Class、Collection、Map、Date或enum）；零依赖（没有依赖其它任何类库除了JDK）。 地址：https://github.com/alibaba/fastjson 4.服务框架 Dubbo Apache Dubbo (incubating) |是阿里巴巴的一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。 地址：https://github.com/alibaba/dubbo 5.企业级流式计算引擎 JStorm JStorm 是参考 Apache Storm 实现的实时流式计算框架，在网络IO、线程模型、资源调度、可用性及稳定性上做了持续改进，已被越来越多企业使用。JStorm 可以看作是 storm 的 java 增强版本，除了内核用纯java实现外，还包括了thrift、python、facet ui。从架构上看，其本质是一个基于 zk 的分布式调度系统。 地址：https://github.com/alibaba/jstorm 6.apns4j apns4j 是 Apple Push Notification Service 的 Java 实现！ 地址：https://github.com/teaey/apns4j 7.分布式数据层 TDDL TDDL 是一个基于集中式配置的 jdbc datasource实现，具有主备，读写分离，动态数据库配置等功能。 地址：https://github.com/alibaba/tb_tddl 8.轻量级分布式数据访问层 CobarClient Cobar Client是一个轻量级分布式数据访问层（DAL）基于iBatis(已更名为MyBatis)和Spring框架实现。 地址：https://github.com/alibaba/cobarclient 9.淘宝定制 JVM：TaobaoJVM TaobaoJVM 基于 OpenJDK HotSpot VM，是国内第一个优化、定制且开源的服务器版Java虚拟机。目前已经在淘宝、天猫上线，全部替换了Oracle官方JVM版本，在性能，功能上都初步体现了它的价值。 地址：http://jvm.taobao.org 10.Java 图片处理类库 SimpleImage SimpleImage是阿里巴巴的一个Java图片处理的类库，可以实现图片缩略、水印等处理。 地址：https://github.com/alibaba/simpleimage 11.redis 的 java 客户端 Tedis Tedis 是另一个 redis 的 java 客户端。Tedis 的目标是打造一个可在生产环境直接使用的高可用 Redis 解决方案。 地址：https://github.com/justified/tedis 12.开源 Java 诊断工具 Arthas Arthas（阿尔萨斯）是阿里巴巴开源的 Java 诊断工具，深受开发者喜爱。 Arthas 采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。 地址：https://alibaba.github.io/arthas/ 13.动态服务发现、配置和服务管理平台 Nacos Nacos 致力于帮助您发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您实现动态服务发现、服务配置管理、服务及流量管理。 Nacos 帮助您更敏捷和容易地构建、交付和管理微服务平台。 Nacos 是构建以“服务”为中心的现代应用架构(例如微服务范式、云原生范式)的服务基础设施。 地址：https://nacos.io/en-us/ 14.Java 解析 Excel 工具 easyexcel Java 解析、生成 Excel 比较有名的框架有 Apache poi、jxl 。但他们都存在一个严重的问题就是非常的耗内存，poi 有一套 SAX 模式的 API 可以一定程度的解决一些内存溢出的问题，但 POI 还是有一些缺陷，比如 07 版 Excel 解压缩以及解压后存储都是在内存中完成的，内存消耗依然很大。easyexcel 重写了 poi 对 07 版 Excel 的解析，能够原本一个 3M 的 excel 用 POI sax 依然需要 100M 左右内存降低到 KB 级别，并且再大的 excel 不会出现内存溢出，03 版依赖 POI 的 sax 模式。在上层做了模型转换的封装，让使用者更加简单方便。 地址：https://github.com/alibaba/easyexcel 15.高可用流量管理框架 Sentinel Sentinel 是面向微服务的轻量级流量控制框架，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。 只要通过 Sentinel API 定义的代码，就是资源，能够被 Sentinel 保护起来。大部分情况下，可以使用方法签名，URL，甚至服务名称作为资源名来标示资源。 地址：https://github.com/alibaba/Sentinel 16.基于多维度 Metrics 的系统度量和监控中间件 SOFALookout Lookout 是一个利用多维度的 metrics 对目标系统进行度量和监控的项目。Lookout 的多维度 metrics 参考 Metrics 2.0 标准。Lookout 项目分为客户端部分与服务器端部分。 客户端是一个 Java 的类库，可以将它植入您的应用代码中采集 metrics 信息，客户端更多详情。 服务端代码部分，将于下一版本提供。通过 LOOKOUT 的服务，可以对 metrics 数据进行收集、加工、存储和查询等处理，另外结合 grafana，可做数据可视化展示。 地址：https://github.com/alipay/sofa-lookout 17.基于 Spring Boot 的研发框架 SOFABoot SOFABoot 是蚂蚁金服开源的基于 Spring Boot 的研发框架，它在 Spring Boot 的基础上，提供了诸如 Readiness Check，类隔离，日志空间隔离等等能力。在增强了 Spring Boot 的同时，SOFABoot 提供了让用户可以在 Spring Boot 中非常方便地使用 SOFAStack 相关中间件的能力。 地址：https://github.com/alipay/sofa-boot 18.轻量级 Java 类隔离容器 SOFAArk SOFAArk 是一款基于 Java 实现的轻量级类隔离容器，由蚂蚁金服公司开源贡献；主要为应用程序提供类隔离和依赖包隔离的能力；基于 Fat Jar 技术，应用可以被打包成一个自包含可运行的 Fat Jar，应用既可以是简单的单模块 Java 应用也可以是 Spring Boot 应用。可访问网址进入快速开始并获取更多详细信息。 地址：https://alipay.github.io/sofastack.github.io/ 19.分布式链路追踪中间件 SOFATracer SOFATracer 是一个用于分布式系统调用跟踪的组件，通过统一的 traceId 将调用链路中的各种网络调用情况以日志的方式记录下来，以达到透视化网络调用的目的。这些日志可用于故障的快速发现，服务治理等。 地址：https://github.com/alipay/sofa-tracer 20.高性能 Java RPC 框架 SOFARPC SOFARPC 是一个高可扩展性、高性能、生产级的 Java RPC 框架。在蚂蚁金服 SOFARPC 已经经历了十多年及五代版本的发展。SOFARPC 致力于简化应用之间的 RPC 调用，为应用提供方便透明、稳定高效的点对点远程服务调用方案。为了用户和开发者方便的进行功能扩展，SOFARPC 提供了丰富的模型抽象和可扩展接口，包括过滤器、路由、负载均衡等等。同时围绕 SOFARPC 框架及其周边组件提供丰富的微服务治理方案。 地址：https://github.com/alipay/sofa-rpc 21.基于 Netty 的网络通信框架 SOFABolt SOFABolt 是蚂蚁金融服务集团开发的一套基于 Netty 实现的网络通信框架。 为了让 Java 程序员能将更多的精力放在基于网络通信的业务逻辑实现上，而不是过多的纠结于网络底层 NIO 的实现以及处理难以调试的网络问题，Netty 应运而生。 为了让中间件开发者能将更多的精力放在产品功能特性实现上，而不是重复地一遍遍制造通信框架的轮子，SOFABolt 应运而生。 地址：https://github.com/alipay/sofa-bolt 22.动态非侵入 AOP 解决方案 JVM-Sandbox JVM-Sandbox，JVM 沙箱容器，一种基于 JVM 的非侵入式运行期 AOP 解决方案。 地址：https://github.com/alibaba/jvm-sandbox 23.面向云的分布式消息领域标准 OpenMessaging OpenMessaging 是由阿里巴巴发起，与雅虎、滴滴出行、Streamlio 公司共同参与创立，旨在创立厂商无关、平台无关的分布式消息及流处理领域的应用开发标准。 地址：https://github.com/openmessaging/openmessaging-java 24.P2P 文件分发系统 Dragonfly Dragonfly（蜻蜓）是阿里自研的 P2P 文件分发系统，用于解决大规模文件分发场景下分发耗时、成功率低、带宽浪费等难题。大幅提升发布部署、数据预热、大规模容器镜像分发等业务能力。 开源版的 Dragonfly 可用于 P2P 文件分发、容器镜像分发、局部限速、磁盘容量预检等。它支持多种容器技术，对容器本身无需做任何改造，镜像分发比 natvie 方式提速可高达 57 倍，Registry 网络出流量降低99.5%以上。 地址：https://github.com/alibaba/Dragonfly 25.LayoutManager 定制化布局方案 vlayout VirtualLayout是一个针对RecyclerView的LayoutManager扩展, 主要提供一整套布局方案和布局间的组件复用的问题。 地址：https://github.com/alibaba/vlayout 26.Java 代码规约扫描插件 P3C 项目包含三部分：PMD 实现、IntelliJ IDEA 插件、Eclipse 插件 地址：https://github.com/alibaba/p3c 作者：Java入门到入坟链接：https://www.jianshu.com/p/b560a912b4bf","tags":[{"name":"开源项目","slug":"开源项目","permalink":"https://fantalovelife.club/tags/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"}]},{"title":"如何超过大多数人","date":"2019-06-23T04:40:36.000Z","path":"2019/06/23/如何超过大多数人/如何超过大多数人/","text":"当你看到这篇文章的标题，你一定对这篇文章产生了巨大的兴趣，因为你的潜意识在告诉你，这是一本人生的“武林秘籍”，而且还是左耳朵写的，一定有干货满满，只要读完，一定可以练就神功并找到超过大多数人的快车道和捷径……然而…… 当你看到我这样开篇时，你一定会觉得我马上就要有个转折，告诉你这是不可能的，一切都需要付出和努力……然而，你错了，这篇文章还真就是一篇“秘籍”，只要你把这些“秘籍”用起来，你就一定可以超过大多数人。而且，这篇文章只有我这个“人生导师”可以写得好。毕竟，我的生命过到了十六进制2B的年纪，踏入这个社会已超过20年，舍我其谁呢？！ P.S. 这篇文章借鉴于《如何写出无法维护的代码》一文的风格……嘿嘿 相关技巧和最佳实践要超过别人其实还是比较简单的，尤其在今天的中国，更是简单。因为，你只看看中国的互联网，你就会发现，他们基本上全部都是在消费大众，让大众变得更为地愚蠢和傻瓜。所以，在今天的中国，你基本上不用做什么，只需要不使用中国互联网，你就很自然地超过大多数人了。当然，如果你还想跟他们彻底拉开，甩他们几个身位，把别人打到底层，下面的这些“技巧”你要多多了解一下。 在信息获取上，你要不断地向大众鼓吹下面的这些事： 让大家都用百度搜索引擎查找信息，订阅微信公众号或是到知乎上学习知识……要做到这一步，你就需要把“百度一下”挂在嘴边，然后要经常在群或朋友圈中转发微信公众号的文章，并且转发知乎里的各种“如何看待……”这样的文章，让他们爱上八卦，爱上转发，爱上碎片。 让大家到微博或是知识星球上粉一些大咖，密切关注他们的言论和动向……是的，告诉大家，大咖的任何想法一言一行都可以在微博、朋友圈或是知识星球上获得，让大家相信，你的成长和大咖的见闻和闲扯非常有关系，你跟牛人在一个圈子里你也会变牛。 把今日头条和抖音这样的APP推荐给大家……你只需要让你有朋友成功地安装这两个APP，他们就会花大量的时间在上面，而不能自拔，要让他们安装其实还是很容易的，你要不信你就装一个试玩一会看看（嘿嘿嘿）。 让大家热爱八卦，八卦并不一定是明星的八卦，还可以是你身边的人，比如，公司的同事，自己的同学，职场见闻，社会热点，争议话题，……这些东西总有一些东西会让人心态有很多微妙的变化，甚至花大量的时间去搜索和阅读大量的观点，以及花大量时间与人辩论争论，这个过程会让人上瘾，让人欲罢不能，然而这些事却和自己没有半毛钱关系。你要做的事就是转发其中一些SB或是很极端的观点，造成大家的一睦讨论后，就早早离场…… 利用爱国主义，让大家觉得不用学英文，不要出国，不要翻墙，咱们已经是强国了……这点其实还是很容易做到的，因为学习是比较逆人性的，所以，只要你鼓吹那些英文无用论，出国活得更惨，国家和民族都变得很强大，就算自己过得很底层，也有大国人民的感觉。然后，在知识学习和技能训练上，让他们不得要领并产生幻觉 让他们混淆认识和知识，以为开阔认知就是学习，让他们有学习和成长的幻觉……培养他们要学会使用碎片时间学习。等他们习惯利用碎片时间吃快餐后，他们就会失去精读一本书的耐性…… 不断地给他们各种各样“有价值的学习资料”，让他们抓不住重点，成为一个微信公众号或电子书“收藏家”…… 让他们看一些枯燥无味的基础知识和硬核知识，这样让他们只会用“死记硬背”的方式来学习，甚至直接让他们失去信心，直接放弃…… 玩具手枪是易用的，重武器是难以操控的，多给他们一些玩具，这样他们就会对玩具玩地得心应手，觉得玩玩具就是自己的专业…… 让他们喜欢直接得到答案的工作和学习方式，成为一个伸手党，从此学习再也不思考…… 告诉他们东西做出来就好了，不要追求做漂亮，做优雅，这样他们就会慢慢地变成劳动密集型…… 让他们觉得自己已经很努力了，剩下的就是运气，并说服他们去‘及时行乐’，然后再也找不到高阶和高效率学习的感觉…… 让他们觉得“读完书”、“读过书”就行了，不需要对书中的东西进行思考，进行总结，或是实践，只要囫囵吞枣尽快读完就等同于学好了……最后，在认知和格局上，彻底打垮他们，让他们变成韭菜。 让他们不要看到大的形势，只看到眼前的一亩三分地，做好一个井底之蛙。其实这很简单，比如，你不要让他们看到整个计算机互联网技术改变人类社会的趋势，你要多让他看到，从事这一行业的人有多苦逼，然后再说一下其它行业或职业有多好…… 宣扬一夜暴富以及快速挣钱的案例，最好让他们进入“赌博类”或是“传销类”的地方，比如：股市、数字货币……要让他们相信各种财富神话，相信他们就是那个幸运儿，他们也可以成为巴菲特，可以成为马云…… 告诉他们，一些看上去很难的事都是有捷径的，比如：21天就能学会机器学习，用区块链就能颠覆以及重构整个世界等等…… 多跟他们讲一些小人物的励志的故事，这样让他们相信，不需要学习高级知识，不需要掌握高级技能，只需要用低等的知识和低级的技能，再加上持续不断拼命重复现有的工作，终有一天就会成功…… 多让他们跟别人比较，人比人不会气死人，但是会让人变得浮躁，变得心急，变得焦虑，当一个人没有办法控制自己的情绪，没有办法让自己静下心来，人会失去耐性和坚持，开始好大喜欢功，开始装逼，开始歪门邪道剑走偏锋…… 让他们到体制内的一些非常稳定的地方工作，这样他们拥有不思进取、怕承担责任、害怕犯错、喜欢偷懒、得过且过的素质…… 让他们到体制外的那些喜欢拼命喜欢加班的地方工作，告诉他们爱拼才会赢，努力加班是一种福报，青春就是用来拼的，让他们喜欢上使蛮力的感觉…… 告诉他们你的行业太累太辛苦，干不到30岁。让他们早点转行，不要耽误人生和青春…… 当他们要做决定的时候，一定要让他们更多的关注自己会失去的东西，而不是会得到的东西。培养他们患得患失心态，让他们认识不到事物真正的价值，失去判断能力……（比如：让他们觉得跟对人拍领导的马屁忠于公司比自我的成长更有价值） 告诉他们，你现有的技能和知识不用更新，就能过好一辈子，新出来的东西没有生命力的……这样他们就会像我们再也不学习的父辈一样很快就会被时代所抛弃…… 每个人都喜欢在一些自己做不到的事上找理由，这种能力不教就会，比如，事情太多没有时间，因为工作上没有用到，等等，你要做的就是帮他们为他们做不到的事找各种非常合理的理由，比如：没事的，一切都是最好的安排；你得不到的那个事没什么意思；你没有面好主要原因是那个面试官问的问题都是可以上网查得到的知识，而不没有问到你真正的能力上；这些东西学了不用很快会忘了，等有了环境再学也不迟…… 最后友情提示一下，上述的这些“最佳实践”你要小心，是所谓，贩毒的人从来不吸毒，开赌场的人从来不赌博！所以，你要小心别自己也掉进去了！这就是“欲练神功，必先自宫”的道理。 相关原理和思维模型对于上面的这些技巧还有很多很多，你自己也可以发明或是找到很多。所以，我来讲讲这其中的一些原理。 一般来说，超过别人一般来说就是两个维度： 在认知、知识和技能上。这是一个人赖以立足社会的能力（参看《程序员的荒谬之言还是至理名言？》和《21天教你学会C++》） 在领导力上。所谓领导力就是你跑在别人前面，你得要有比别人更好的能力更高的标准（参看《技术人员发展之路》）首先，我们要明白，人的技能是从认识开始，然后通过学校、培训或是书本把“零碎的认知”转换成“系统的知识”，而有要把知识转换成技能，就需要训练和实践，这样才能完成从：认识 -&gt; 知识 -&gt; 技能 的转换。这个转换过程是需要耗费很多时间和精力的，而且其中还需要有强大的学习能力和动手能力，这条路径上有很多的“关卡”，每道关卡都会过滤掉一大部分人。比如：对于一些比较枯燥的硬核知识来说，90%的人基本上就倒下来，不是因为他们没有智商，而是他们没有耐心。 认知要在认知上超过别人，就要在下面几个方面上做足功夫： 1）信息渠道。试想如果别人的信息源没有你的好，那么，这些看不见信息源的人，只能接触得到二手信息甚至三手信息，只能获得被别人解读过的信息，这些信息被三传两递后必定会有错误和失真，甚至会被传递信息的中间人hack其中的信息（也就是“中间人攻击”），而这些找不出信息源的人，只能“被人喂养”，于是，他们最终会被困在信息的底层，永世不得翻身。（比如：学习C语言，放着原作者K&amp;R的不用，硬要用错误百出谭浩强的书，能有什么好呢？） 2）信息质量。信息质量主要表现在两个方面，一个是信息中的燥音，另一个是信息中的质量等级，我们都知道，在大数据处理中有一句名言，叫 garbage in garbage out，你天天看的都是垃圾，你的思想和认识也只有垃圾。所以，如果你的信息质量并不好的话，你的认知也不会好，而且你还要花大量的时间来进行有价值信息的挖掘和处理。 3）信息密度。优质的信息，密度一般都很大，因为这种信息会逼着你去干这么几件事，a）搜索并学习其关联的知识，b）沉思和反省，c）亲手去推理、验证和实践……一般来说，经验性的文章会比知识性的文章会更有这样的功效。比如，类似于像 Effiective C++/Java，设计模式，Unix编程艺术，算法导论等等这样的书就是属于这种密度很大的书，而像Netflix的官方blog和AWS CTO的blog等等地方也会经常有一些这样的文章。 知识要在知识上超过别人，你就需要在下面几个方面上做足功夫： 1）知识树（图）。任何知识，只在点上学习不够的，需要在面上学习，这叫系统地学习，这需要我们去总结并归纳知识树或知识图，一个知识面会有多个知识板块组成，一个板块又有各种知识点，一个知识点会导出另外的知识点，各种知识点又会交叉和依赖起来，学习就是要系统地学习整个知识树（图）。而我们都知道，对于一棵树来说，“根基”是非常重要的，所以，学好基础知识也是非常重要的，对于一个陌生的地方，有一份地图是非常重要的，没有地图的你只会乱窜，只会迷路、练路、走冤枉路！ 2）知识缘由。任何知识都是有缘由的，了解一个知识的来龙去脉和前世今生，会让你对这个知识有非常强的掌握，而不再只是靠记忆去学习。靠记忆去学习是一件非常糟糕的事。而对于一些操作性的知识（不需要了解由来的），我把其叫操作知识，就像一些函数库一样，这样的知识只要学会查文档就好了。能够知其然，知其所以然的人自然会比识知识到表皮的人段位要高很多。 3）方法套路。学习不是为了找到答案，而是找到方法。就像数学一样，你学的是方法，是解题思路，是套路，会用方程式解题的和不会用方程式解题的在解题效率上不可比较，而在微积分面前，其它的解题方法都变成了渣渣。你可以看到，掌握高级方法的人比别人的优势有多大，学习的目的就是为了掌握更为高级的方法和解题思路。 技能要在技能上超过别人，你就需要在下面几个方面做足功夫： 1）精益求精。如果你想拥有专业的技能，你要做不仅仅是拼命地重复一遍又一遍的训练，而是在每一次重复训练时你都要找到更好的方法，总结经验，让新的一遍能够更好，更漂亮，更有效率，否则，用相同的方法重复，那你只不过在搬砖罢了。 2）让自己犯错。犯错是有利于成长的，这是因为出错会让人反思，反思更好的方法，反思更完美的方案，总结教训，寻求更好更完美的过程，是技能升级的最好的方式。尤其是当你在出错后，被人鄙视，被人嘲笑后，你会有更大的动力提升自己，这样的动力才是进步的源动力。当然，千万不要同一个错误重复地犯！ 3）找高手切磋。下过棋，打个球的人都知道，你要想提升自己的技艺，你必需找高手切磋，在和高手切磋的过程中你会感受到高手的技能和方法，有时候你会情不自禁地哇地一下，我靠，还可以这么玩！ 领导力最后一个是领导力，要有领导力或是影响力这个事并不容易，这跟你的野心有多大，好胜心有多强 ，你愿意付出多少很有关系，因为一个人的领导力跟他的标准很有关系，因为有领导力的人的标准比绝大多数人都要高。 1）识别自己的特长和天赋。首先，每个人DNA都可能或多或少都会有一些比大多数人NB的东西（当然，也可能没有），如果你有了，那么在你过去的人生中就一定会表现出来了，就是那种大家遇到这个事会来请教你的寻求你帮助的现象。那种，别人要非常努力，而且毫不费劲的事。一旦你有了这样的特长或天赋，那你就要大力地扩大你的领先优势，千万不要进到那些会限制你优势的地方。你是一条鱼，你就一定要把别人拉到水里来玩，绝对不要去陆地上跟别人拼，不断地在自己的特长和天赋上扩大自己的领先优势，彻底一骑绝尘。 2）识别自己的兴趣和事业。没有天赋也没有问题，还有兴趣点，都说兴趣是最好的老师，当年，Linus就是在学校里对minx着迷了，于是整出个Linux来，这就是兴趣驱动出的东西，一般来说，兴趣驱动的事总是会比那些被动驱动的更好。但是，这里我想说明一下什么叫“真∙兴趣”，真正的兴趣不是那种三天热度的东西，而是那种，你愿意为之付出一辈子的事，是那种无论有多大困难有多难受你都要死磕的事，这才是“真∙兴趣”，这也就是你的“野心”和“好胜心”所在，其实上升到了你的事业。相信我，绝大多数人只有职业而没有事业的。 3）建立高级的习惯和方法。没有天赋没有野心，也还是可以跟别人拼习惯拼方法的，只要你有一些比较好的习惯和方法，那么你一样可以超过大多数人。对此，在习惯上你要做到比较大多数人更自律，更有计划性，更有目标性，比如，每年学习一门新的语言或技术，并可以参与相关的顶级开源项目，每个月训练一个类算法，掌握一种算法，每周阅读一篇英文论文，并把阅读笔记整理出来……自律的是非常可怕的。除此之外，你还需要在方法上超过别人，你需要满世界的找各种高级的方法，其中包括，思考的方法，学习的方法、时间管理的方法、沟通的方法这类软实力的，还有，解决问题的方法（trouble shooting 和 problem solving），设计的方法，工程的方法，代码的方法等等硬实力的，一开始照猫画虎，时间长了就可能会自己发明或推导新的方法。 4）勤奋努力执着坚持。如果上面三件事你都没有也没有能力，那还有最后一件事了，那就是勤奋努力了，就是所谓的“一万小时定律”了（参看《21天教你学会C++》中的十年学编程一节），我见过很多不聪明的人，悟性也不够（比如我就是一个），别人学一个东西，一个月就好了，而我需要1年甚至更长，但是很多东西都是死的，只要肯花时间就有一天你会搞懂的，耐不住我坚持十年二十年，聪明的人发明个飞机飞过去了，笨一点的人愚公移山也过得去，因为更多的人是懒人，我不用拼过聪明人，我只用拼过那些懒人就好了。 好了，就这么多，如果哪天你变得消极和不自信，你要来读读我的这篇文章，子曰：温故而知新。 （全文完）转载：https://coolshell.cn/articles/19464.html","tags":[{"name":"随笔","slug":"随笔","permalink":"https://fantalovelife.club/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"消息中间件使用场景","date":"2018-06-06T09:30:14.000Z","path":"2018/06/06/消息中间件使用场景/消息中间件使用场景/","text":"消息中间件出现的场景：BOSS中心和CRM中心存在不同的数据库，一些诸如停开机用户数据同步和缴费数据同步的过程以前老系统是使用应用集成平台扫描表做数据搬运的动作。搬运过程中对数据库的压力和IO的压力都很大，处理效率低并且对传输过程中丢失的数据无法追踪，无重试和保证机制。在这个需求下，将使用到同步的场景采用消息中间件来触发。 具体流程是：将需要同步的主题和数据从对象池中取出，没有的话就新建一个，但主题保证是已有的。通过NIO将消息主体等内容发送到消息中间件，并对数据做个存储（Mysql集群存，主备相互备份）数据库的建模按照一个主题来建表，队列分区建表有点浪费资源，消息中间件根据主题发送到相应的主机上去处理，如果因为任何原因失败了，将重试三次，三次后仍失败将消息状态置为失败。消息发送到相应主机后，存储到消息接口表中，根据进程扫描本地接口表做同步处理。处理成功后反馈给消息中间件，然后再发送消息给生产者告知。至此消息处理完毕。（ACK过程，第一次发送是SEND状态，第二次发送是COMMIT状态，全部状态都得到反馈，消息发送成功） 可以说说消息中间件使用的几点技术： 1.整体消息中间件系统参考这个是一个真实生产化的消息系统案例，由 1 个架构师 +2 个高级工程师设计开发，第一期研发测试到上生产约 3 个月，目前该系统日处理消息量过亿。假定公司因为业务需要，要构建一套分布式消息系统 MQ，类似 Kafka 这样的，这个问题看起来很大很复杂，但是如果你抽丝剥茧，透过现象看本质，Kafka 这样的消息系统本质上是下图这样的抽象概念： 队列其实就是类似数组一样的结构（用数组建模有个好处，有索引可以重复消费），里头存放消息 (Msg)，数组一头进消息，一头出消息； 左边是若干生产者 (Producer)，往队列里头发消息； 右边是若干消费者 (Consumer)，从队列里头消费消息； 对于生产者和消费者来说，他们不关心队列实现细节，所以给队列一个更抽象的名字，叫主题 (Topic)； 考虑到系统的扩容和分布式能力，一般一个主题由若干个队列组成，这些队列也叫分区 (Partition)，而且这些队列可能还是分布在不同机器上的，例如下图中 Topic A 的两个队列分布在 DataNode1 节点上，另外两个队列分布在 DataNode2 节点上，这样以后 Topic 可以按需扩容，DataNode 也可以按需增加。当然这些细节由 MQ 系统屏蔽，用户只关心主题，不关心底层实现。 单个数组队列的建模是整个 MQ 系统的关键，我们知道 Kafka 使用 append only file 建模队列，存取速度快。假设我们要存业务数据需要更高可靠性，也可以用数据库表来建模数组队列，如下图所示： 一个队列 (或者一个分区) 对应一张数据库表，表中的一个记录就是一条消息，表采用自增 id，相当于数组索引。这张表是 insert only 的，且 MySQL 会自动对自增 id 建优化索引，没有其它索引，所以插入和按 id 查找速度都非常快。下面是总体元数据模型： 一个主题 Topic 对应若干个队列 Queue 一个数据节点 DataNode 上可以住若干个队列 Queue 消费者 Consumer 和队列 Queue 之间是多对多关系，通过消费者偏移 Consumer Offset 进行关联 一个消费者组 Consumer Group 里头有若干个消费者 Consumer，它们共同消费同一个主题 Topic至此，我们对 MQ 的抽象建模工作完成，下面的工作是将这个模型映射到具体实现，经过分解，整个系统由若干个子模块组成，每个子模块实现后拼装起来的 MQ 总体架构如下图所示： Admin 模块管理数据库节点，生产者，消费者 (组)，主题，队列，消费偏移等元数据信息。 Broker 模块定期从 Admin 数据库同步元数据，接受生产者消息，按路由规则将消息存入对应的数据库表 (队列) 中；同时接受消费者请求，根据元数据从对应数据库表读取消息并发回消费者端。Broker 模块也接受消费者定期提交消费偏移。 Producer 接受应用发送消息请求，将消息发送到 Broker； Consumer 从 Broker 拉取消息，供上层应用进一步消费； 客户端和 Broker 之间走 Thrift over HTTP 协议，中间通过域名走 Nginx 代理转发； 这个设计 Broker 是无状态，易于扩展。架构思维总结：整个架构设计的思路体现了先总体抽象，再分解按模块抽象并实现，最后组合成完整的 MQ 系统，也就是 抽象 + 分治。这个 MQ 的实现工作量并不大，属于小型系统范畴，初期设计和开发由 1 个架构师 +2 个中高级工程师可以搞定。在初期研发和上生产之后，根据用户的不断反馈，系统设计经过多次优化和调整，符合三分架构、七分演化的 演化式架构 理念。目前该系统已经进入 V2 版本的架构和研发，其架构仍在持续演化当中，用户需求的多样性和对系统灵活性的更高要求，是系统架构演化的主要推动力。 2.具体几个使用关键技术a.首先是apache的commonpool2 Jar包 其实也是缓存IO的一种方式项目启动起来的时候，会static创建一个GenericKeyedObjectPool对象，然后将常用的ClientID放进去对象池初始化使用，方便后面服务调用时候每次发送前的处理。往对象池中塞对象GenericKeyedObjectPool（属于apache.commonpool2包中的接口），这个对象池技术运用的范围就很广了。比如Jedis框架中使用的对象池缓存技术就是依赖的commonpool2 Jar包去实现的。 几个概念：对象池(ObjectPool): 掌管对象的生命周期，获取，激活，验证，钝化，销毁等池对象(PooledObject): 池化对象，是需要放到ObjectPool对象的一个包装类。添加了一些附加的信息，比如说状态信息，创建时间，激活时间，关闭时间等池对象工厂(PooledObjectFactory): 用来创建池对象, 将不用的池对象进行钝化(passivateObject), 对要使用的池对象进行激活(activeObject), 对池对象进行验证(validateObject), 对有问题的池对象进行销毁(destroyObject)等工作 对象池化主要用于减少对象在创建和销毁上面的开销，如果是小对象则不需要池化，如果是大对象可以考虑池化，对于像数据库连接、网络之类的重对象来说是很有必要池化的，开发者自己根据需求判断，如果创建某种对象成为了影响程序性能的关键因素则需要池化。 关系图如下： ObjectPool1234567891011121314151617181920212223&#x2F;&#x2F;从池中获取对象T borrowObject() throws Exception, NoSuchElementException, IllegalStateException;&#x2F;&#x2F;将对象放回池中void returnObject(T obj) throws Exception;&#x2F;&#x2F;废弃对象void invalidateObject(T obj) throws Exception;&#x2F;&#x2F;添加对象void addObject() throws Exception, IllegalStateException, UnsupportedOperationException;&#x2F;&#x2F;获取空闲对象个数int getNumIdle();&#x2F;&#x2F;获取活跃对象个数int getNumActive();&#x2F;&#x2F;清除池，池可用void clear() throws Exception, UnsupportedOperationException;&#x2F;&#x2F;关闭池，池不可用void close(); PooledObject123456789101112131415161718192021222324252627282930313233343536&#x2F;&#x2F;获得目标对象T getObject();long getCreateTime();long getActiveTimeMillis();long getIdleTimeMillis();long getLastBorrowTime();long getLastReturnTime();long getLastUsedTime();boolean startEvictionTest();boolean endEvictionTest(Deque&lt;PooledObject&lt;T&gt;&gt; idleQueue);boolean allocate();boolean deallocate();void invalidate();void setLogAbandoned(boolean logAbandoned);void use();void printStackTrace(PrintWriter writer);PooledObjectState getState();void markAbandoned();void markReturning(); PooledObjectFactory// 创建一个新对象;当对象池中的对象个数不足时,将会使用此方法来”输出”一个新的”对象”,并交付给对象池管理PooledObject makeObject() throws Exception; // 销毁对象,如果对象池中检测到某个”对象”idle的时间超时,或者操作者向对象池”归还对象”时检测到”对象”已经无效,那么此时将会导致”对象销毁”;// “销毁对象”的操作设计相差甚远,但是必须明确:当调用此方法时,”对象”的生命周期必须结束.如果object是线程,那么此时线程必须退出;// 如果object是socket操作,那么此时socket必须关闭;如果object是文件流操作,那么此时”数据flush”且正常关闭.void destroyObject(PooledObject p) throws Exception; // 检测对象是否”有效”;Pool中不能保存无效的”对象”,因此”后台检测线程”会周期性的检测Pool中”对象”的有效性,如果对象无效则会导致此对象从Pool中移除,并destroy;// 此外在调用者从Pool获取一个”对象”时,也会检测”对象”的有效性,确保不能讲”无效”的对象输出给调用者;// 当调用者使用完毕将”对象归还”到Pool时,仍然会检测对象的有效性.所谓有效性,就是此”对象”的状态是否符合预期,是否可以对调用者直接使用;// 如果对象是Socket,那么它的有效性就是socket的通道是否畅通/阻塞是否超时等.boolean validateObject(PooledObject p); // “激活”对象,当Pool中决定移除一个对象交付给调用者时额外的”激活”操作,比如可以在activateObject方法中”重置”参数列表让调用者使用时感觉像一个”新创建”的对象一样;如果object是一个线程,可以在”激活”操作中重置”线程中断标记”,或者让线程从阻塞中唤醒等;// 如果object是一个socket,那么可以在”激活操作”中刷新通道,或者对socket进行链接重建(假如socket意外关闭)等.void activateObject(PooledObject p) throws Exception; // “钝化”对象,当调用者”归还对象”时,Pool将会”钝化对象”；钝化的言外之意,就是此”对象”暂且需要”休息”一下.// 如果object是一个socket,那么可以passivateObject中清除buffer,将socket阻塞;如果object是一个线程,可以在”钝化”操作中将线程sleep或者将线程中的某个对象wait.需要注意的时,activateObject和passivateObject两个方法需要对应,避免死锁或者”对象”状态的混乱.void passivateObject(PooledObject p) throws Exception;` 实例class ConnectionTestFactory extends BaseKeyedPooledObjectFactory &#123;12345678910111213141516171819202122232425262728293031323334 private static final Logger LOGGER &#x3D; LoggerFactory.getLogger(ConnectionTestFactory.class); @Override public ConnectionTest create(String key) throws Exception &#123; return new ConnectionTest(key); &#125; @Override public PooledObject&lt;ConnectionTest&gt; wrap(ConnectionTest value) &#123; return new DefaultPooledObject&lt;&gt;(value); &#125; public static void main(String[] args) &#123; KeyedObjectPool&lt;String, ConnectionTest&gt; objectPool &#x3D; new GenericKeyedObjectPool&lt;&gt;(new ConnectionTestFactory()); try &#123; &#x2F;&#x2F;添加对象到池，重复的不会重复入池 objectPool.addObject(&quot;1&quot;); objectPool.addObject(&quot;2&quot;); objectPool.addObject(&quot;3&quot;); &#x2F;&#x2F; 获得对应key的对象 ConnectionTest connectionTest1 &#x3D; objectPool.borrowObject(&quot;1&quot;); LOGGER.info(&quot;borrowObject &#x3D; &#123;&#125;&quot;, connectionTest1); &#x2F;&#x2F; 释放对象 objectPool.returnObject(&quot;1&quot;, connectionTest1); &#x2F;&#x2F;清除所有的对象 objectPool.clear(); &#125; catch (Exception e) &#123; LOGGER.error(&quot;&quot;, e); &#125; &#125;&#125; Config详解 lifo：连接池放池化对象方式，默认为truetrue：放在空闲队列最前面false：放在空闲队列最后面 fairness：等待线程拿空闲连接的方式，默认为falsetrue：相当于等待线程是在先进先出去拿空闲连接 maxWaitMillis：当连接池资源耗尽时，调用者最大阻塞的时间，超时将跑出异常。单位，毫秒数;默认为-1.表示永不超时. 默认值 -1maxWait：commons-pool1中 minEvictableIdleTimeMillis：连接空闲的最小时间，达到此值后空闲连接将可能会被移除。负值(-1)表示不移除；默认值1000L * 60L * 30L softMinEvictableIdleTimeMillis：连接空闲的最小时间，达到此值后空闲链接将会被移除，且保留“minIdle”个空闲连接数。负值(-1)表示不移除。默认值1000L * 60L * 30L numTestsPerEvictionRun：默认值 3 evictionPolicyClassName：默认值org.apache.commons.pool2.impl.DefaultEvictionPolicy testOnCreate：默认值false testOnBorrow：向调用者输出“链接”资源时，是否检测是有有效，如果无效则从连接池中移除，并尝试获取继续获取。默认为false。建议保持默认值. testOnReturn：默认值false testWhileIdle：向调用者输出“链接”对象时，是否检测它的空闲超时；默认为false。如果“链接”空闲超时，将会被移除；建议保持默认值。默认值false timeBetweenEvictionRunsMillis：“空闲链接”检测线程，检测的周期，毫秒数。如果为负值，表示不运行“检测线程”。默认值 -1L blockWhenExhausted：默认值true jmxEnabled：默认值true jmxNamePrefix：默认值 pool jmxNameBase：默认值 null maxTotal：链接池中最大连接数，默认值8commons-pool1 中maxActive改成maxTotal maxIdle：连接池中最大空闲的连接数,默认为8 minIdle: 连接池中最少空闲的连接数,默认为0 softMinEvictableIdleTimeMillis: 连接空闲的最小时间，达到此值后空闲链接将会被移除，且保留“minIdle”个空闲连接数。默认为-1. numTestsPerEvictionRun: 对于“空闲链接”检测线程而言，每次检测的链接资源的个数。默认为3. whenExhaustedAction: 当“连接池”中active数量达到阀值时，即“链接”资源耗尽时，连接池需要采取的手段, 默认为1：0：抛出异常1：阻塞，直到有可用链接资源2：强制创建新的链接资源 但是这里需要说明的是，对象池技术很容易成为系统IO的瓶颈。ObjectPool 常見的幾個 ObjectPool 實現性能都很差，反而很容易成為性能瓶頸。 Stormpot 性能強悍，不過存在偶爾死鎖的問題，而且作者也停止維護了。 HikariCP 性能不錯，不過其本身是一款數據庫連接池，用作 ObjectPool 並不稱手。我的建議是儘量避免使用 ObjectPool，轉而使用替代技術。更重要的是 Netty 的 Channel 是線程安全的，並不需要使用 ObjectPool 來管理。只需要一個簡單的容器來存儲 Channel，用的時候使用 負載均衡策略 選出一個 Channel 出來就行了。 framework thrpt (ops/us) ThreadLocal 685.418 Stormpot 272.934 HikariCP 139.126 SegmentLock 19.415 CommonsPool2 1.107 CommonsPool 0.276","tags":[{"name":"消息中间件","slug":"消息中间件","permalink":"https://fantalovelife.club/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"}]},{"title":"BOSS系统分布式架构","date":"2018-04-06T13:07:15.000Z","path":"2018/04/06/BOSS系统分布式架构/BOSS系统分布式架构/","text":"首先说下安徽移动系统BOSS系统的基本属性和移动系统中承担的所要职务整个移动系统中其实是分了很多中心的，BOSS（基本业务支撑）、CRM（客户关系处理）、订单中心（为了营业统计各种业务办理和缴费等比较重要操作的数据报表来源）、ESB（服务处理总线）等。其中就BOSS分为了三个子系统，账务处理、计费业务、账务管理。自己所在的部门也就是账务管理，处理移动各种账务关系的部门 比如BOSS比较重要的功能发票、缴费等都放在了我们部门上。 账务管理系统Java化和其他移动移动Java化所使用的架构模式是一致的系统基本的框架采用Spring和iBatis搭配使用，数据库使用Oracle延续之前C使用的数据库系统，在Java之前也做了很多调研使用MySQL、PostgreSQL这样的关系数据库，但是考虑到Java化项目比较紧急 数据库改用调研也就搁置了（其实本身想使用MySQL做分布式数据库的，但是考虑到老员工都比较熟悉Oracl也就推了又推）。在我看来使用MySQL是很好的选择，本身他对分布式就有很好的支持，几个库搭建分布式数据库可以缓轻很大来在缴费这一边的业务来源入库，还有每个月欠费预销这种业务对数据库IO的折磨。当然除了基本的Spring和iBatis还有很多公司自研的很多框架，基本上都是在开源项目上的增加业务。 然后说说整个移动系统的架构模式，基本的分布式RPC框架，因为前面也说了移动系统的子中心很多，跨中心这种交互就使用了业内很成熟的RPC框架模式，采用了Alibaba的Dubbo作为基础框架改写自有的一套框架。其实基础的核心都没有变，Netty作为网络通信，ZooKeeper作为注册中心来使用，要说改动了也就是中间加了很多自定义的Log功能和ESB服务缓存的功能。ESB这一块的注册服务缓存，都用的Oracle自家的Coherence缓存来实现的，对于这个缓存自己也不是很了解，只知道他在永久缓存上性能很突出，零时缓存就做的很不足。 —-To Be Continue（最近睡眠不足，等下再写）","tags":[{"name":"架构的一点点探索","slug":"架构的一点点探索","permalink":"https://fantalovelife.club/tags/%E6%9E%B6%E6%9E%84%E7%9A%84%E4%B8%80%E7%82%B9%E7%82%B9%E6%8E%A2%E7%B4%A2/"}]},{"title":"HBase应用场景","date":"2018-03-29T03:28:17.000Z","path":"2018/03/29/HBase应用场景/HBase应用场景/","text":"最近在VPS上搭建HBase还没来的及总结，又忙着去看了看公司使用HBase的场景，所以在此做个总结顺带把HBase一些基本东西复习下 1、BOSS系统中处理详单数据时使用到了HBase数据库。因为计费处理话单文件是零散的、无序的、大存储量的。而且计费下发过来的文件是一种结构化的，固定形式的。所以如果需要持久化的话非常适合HBase这种分布式列数据库方式存储。查询语言对Java也有很好支持（除非与其他框架一起使用，如 Phoenix、Hive），不像关系数据库需要使用SQL语句。HBase的索引方式只支持Row-Key（除非和其他技术在一起用）, HBase的事务是单个Row级别的。而且像详单这种数据量增速很快的东西，使用传统关系数据库做拓展和扩容是非常困难的，往往建立在昂贵的硬件和性能优化上，HBase通过增加Region数量就可以达到此的效果。 Hive和HBase使用区别类似的有例如Hive这种数据库存储，但是Hive的场景适合统计一段时间内的数据，而且不能实时返回数据。例如，用来计算趋势或者网站的日志。Hive 不应该用来进行实时的查询（Hive 的设计目的，也不是支持实时的查询）。因为它需要很长时间才可以返回结果；HBase 则非常适合用来进行大数据的实时查询，例如 Facebook 用 HBase 进行消息和实时的分析。对于 Hive 和 HBase 的部署来说，也有一些区别，Hive 一般只要有 Hadoop 便可以工作。而 HBase 则还需要 Zookeeper 的帮助（Zookeeper，是一个用来进行分布式协调的服务，这些服务包括配置服务，维护元信息和命名空间服务）。再而，HBase 本身只提供了 Java 的 API 接口，并不直接支持 SQL 的语句查询，而 Hive 则可以直接使用 HQL（一种类 SQL 语言）。如果想要在 HBase 上使用 SQL，则需要联合使用 Apache Phonenix，或者联合使用 Hive 和 HBase。但是和上面提到的一样，如果集成使用 Hive 查询 HBase 的数据，则无法绕过 MapReduce，那么实时性还是有一定的损失。Phoenix 加 HBase 的组合则不经过 MapReduce 的框架，因此当使用 Phoneix 加 HBase 的组成，实时性上会优于 Hive 加 HBase 的组合，我们后续也会示例性介绍如何使用两者。最后我们再提下 Hive 和 HBase 所使用的存储层，默认情况下 Hive 和 HBase 的存储层都是 HDFS。但是 HBase 在一些特殊的情况下也可以直接使用本机的文件系统。例如 Ambari 中的 AMS 服务直接在本地文件系统上运行 HBase。 表 1. HBase 与 RDBMS 的区别 HBase RDBMS 硬件架构 类似于 Hadoop 的分布式集群，硬件成本低廉 传统的多核系统，硬件成本昂贵 容错性 由软件架构实现，由于由多个节点组成，所以不担心一点或几点宕机 一般需要额外硬件设备实现 HA 机制 数据库大小 PB GB、TB 数据排布方式 稀疏的、分布的多维的 Map 以行和列组织 数据类型 Bytes 丰富的数据类型 事物支持 ACID 只支持单个 Row 级别 全面的 ACID 支持，对 Row 和表 查询语言 只支持 Java API （除非与其他框架一起使用，如 Phoenix、Hive） SQL 索引 只支持 Row-key，除非与其他技术一起应用，如 Phoenix、Hive 支持 吞吐量 百万查询/每秒 数千查询/每秒 当然BOSS系统中也会保存2个月详单的数据放在物理数据库中作为备份，所以当BOSS系统使用大数据量查询时候，HBase配合HadHoop和ZooKeeper可以通过ZK来达到HA的效果，如果单纯将HBase作为单机部署其实发挥不了太大作用，搭配分布式部署起来可以发挥快速作用，ZK负责至少一个HBase Master可用，Hadoop则给Hbase提供HDFS作为存储基础，这样存取速度、容错性都有很好的保证。 2、BOSS系统在ROW-KEY上的设计a.首先Row-key的设计要保证唯一性，我们将手机号码倒置+时间戳和详单专业配置匹配，可以保证其唯一性。b.其次Row-key在保证唯一性前提下，还需要尽量缩小Row-key占用的字节数，这样可以提高搜索效率，缩小搜索范围。c.接着要考虑Row-key设计对访问热点和存储负载的尽量分散，比如说手机号码这一类从13开始就有很多号段很类似的，如果直接使用手机号码也可以达到唯一性，但是这样会让Row-key哈希后存储的很集中 随之访问热点也会很集中对于Region是很大的负担，也达不到应有的效率。但是倒置的话会让尽量分散开，保证了效率和负载。ex：put ‘sdetail_201704’,’05186155281 P20170418076652A60A742F2E’,’c1:d1’,’P|P11|PW|||18255168150|20170418|092802|551|LBMP20140228551.087|1O2000000000000000|02280928005890|1|1|000000||5515515101366|5515515101366|9000181003|5|0|100798024434565280|5|||||201704218000000|5|5|5|||$’ 就例如上面：05186155281 P20170418076652A60A742F2E 这种Row-key去设计 3、再说说BOSS Java化项目调用HBase的地方其实本身HBase已经提供了很好的对Java API的支持比如Get Scan这一类，但是为了保证业务逻辑的分离，公司计费方面负责详单数据处理，于是让计费侧做了接口我们来调用。 调用的方式就是很简单，和计费侧契约规定使用定长的TCP协议来接收返回数据，前1-2指定Column-key 或者 Qulifimer “DC”（在 Hbase 中，Row-key 加上 CF 加上 Qulifier 再加上一个时间戳才可以定位到一个单元格数据（Hbase 中每个单元格默认有 3 个时间戳的版本数据）），3-6指定消息体（没有HTTP这类消息头什么的，浪费IO），最后几位指定消息长度和是否结束标志（因为详单数据意味着很多，需要循环去取）。这样设计有点类似Dubbo的通信协议，删除无用信息，只保留业务信息和关键信息，提高IO效率。 然后计费侧根据我们的参数，做一些处理后Scan一定范围，这个范围根据手机号 和 时间就已经变得很小了，所以忽略了查询的时间，IO本身也没有太多无用信息，保证了BOSS查询特大数据量详单的效率。","tags":[{"name":"HBase","slug":"HBase","permalink":"https://fantalovelife.club/tags/HBase/"}]},{"title":"2017总结","date":"2018-03-10T01:45:14.000Z","path":"2018/03/10/2017总结/2017总结/","text":"2017真我2017年觉得时间过的很快，可能是更多时间投入到工作中了，也没在意每个月的更迭。所以也没什么时间来写文章了。 先说说自己的收获吧 去年给自己购了俩台服务器，一台Aliyun、一台VPS。Aliyun自然是部署自己玩的应用还有就是练习下以前零散学习的Linux操作，VPS不用说了，自然是部署个SS 看一看外面的世界，以前都是购买VPN，现在自己部署个洛杉矶机房的 速度还不错 很值有兴趣的朋友可以看看 购买选择看了很多论坛，放假回来就直接买了CN2 DC8的洛杉矶机房专线，具体参考可以看看搬瓦工的搬瓦工VPS-竞价比较高 搭建SSR搬瓦工对ssr搭建支持也非常棒，可以一键部署。这个网上教程很多，没什么可说的。其中需要注意一点的就是搭建好服务、本地客户端配置好之后，有可能无法正常Google、FQ。这个时候重启一下VPS或者SSR服务试一试。 SSH登录SSH远程登录VPS也是折腾VPS的基本需求之一。网上也有许多教程，Mac下SSH客户端我用的是iterm2，Windows平台下推荐的是Putty。其中需要注意的是登录密码不要搞错了，个人就是把VPS网页登录的密码当成远程登录VPS的密码，折腾了好久才发现。在VPS的控制台界面，左侧有一个root password modifiaction 选项，进了该页面即可获得远程登录SSH的随机密码。 SSH免密码登录每一次都输入密码，太难受了，当初Git也是SSH登录，自然有了免密码登录需求。很简单Google一下就有了相应的文章，这里推荐阮一峰老师的SSH原理与运用（一）：远程登录。很详细，跟着一步一步做就好了。 安装Python3.xLinux系统自带低版本的Python，比如Python2.6，但是不太好用，因此需要升级Python至3.x版本。注意是升级，不要删除老版本的Python，因为系统有许多东西依赖老版本的Python，相关需要安装的东西建议参考博文升级python2.7和安装pip,easy_install和setuptool。 尝试跑Python代码cd到根目录，建立project文件夹，里面就放置各种Python脚本即可。另外如果需要对Python版本有依赖的话，一定要用虚拟环境来管理。相关博文Kickstarting Flask on Ubuntu - Setup and Deployment.在上述博文中将学习到虚拟环境管理、Nginx配置、Supervisor配置、部署、GitHook、Automatic等内容。相信阅读完上述内容，你会有许多收获。 好了说完这些题外，这一年还是看了很多书的。看书使我开心😎 局外人一本书说尽了司法运作把人性摧残彻底的故事。总有人面对眼前一切都表现的毫不在乎，但这不是司法将他定罪的原因。加缪笔下的默尔索着力揭示了现代司法罗织罪状的邪恶。默尔索很干脆的承认自己犯了杀人命案，在面对人群社会与司法机制。感叹加缪23岁时 就能写出这样的故事。 容忍与自由看了胡适先生这么些个书，大多摘自他在《新青年》发表的文章以及他在北平和台湾个大学的演说，还有他在北大上课的笔记。胡适先生所推崇的思想无外乎: 读书这件事，要求实：进一寸有一寸的欢喜，每一步都踌躇满志才可以。自由解放，不是革命，而是由于自己 忠于自己。 我对胡适先生的印象就是，先生自己把西洋学习到的一套东西，真真切切的想融入到年轻人身上，再让年轻人自己去揣摩这些东西的作用。和孔子的“有教无类”有一些想法上的共鸣。所以说胡适先生 可以尊称为先生。 次贷危机书也就翻了一些自己感兴趣的章节跳着看，本身对金融也不是很了解，在当下国内次贷的泛滥，满屏的免评估小额贷款，学生和年轻人大多经不住这诱惑，最后带来的只能是失信和贷款冻结。只是说看了美国和日本的金融危机 历史总是遵循着轨迹发展的。 梵高·手稿书中记录了大量梵高画作的手稿和书信手稿。书信中不免看出当时梵高被一个镇的神父和大多数不理解他的人逼进疯人院的痛苦和失望。 创新公司·皮克斯启示作者就是皮克斯三位创始人之一埃德文·卡特姆写的。从他的角度描写皮克斯保持了这么久的活力是从哪里来的，包括和乔布斯共事的一些趣事和乔布斯一些理念是如何影响皮克斯到现在的。这本书我觉得每一个有创业梦想的人或者说正在创业的人都应该看的。埃德文·卡特姆说了很多皮克斯艰难时期是如何度过的，从迪斯尼不看好电脑动画制作，到迪斯尼愿意提供最好的剧本与皮克斯合作，这期间他所经历的一切，都是值得品读的。 算法图解算法的知识本身自己没有仔细研究过，翻了几页算法导论也是看的头疼。我是个喜欢图形记忆和了解的人，所以对这种抽象图形化的东西 接受还是很快的。作者用Python演示算法，又能深入了解算法，又能练习Python 何乐不为。 还有很多书就不想列举了，总之看书使我快乐一定觉得我这一年肯定没好好学习，不不。。。计算机类的书太贵了，我真的不舍得。。。所以都下了电子书版本来看，平时工作中需要看哪一类，也方便一些。比如推荐给大家： 《Java性能权威指南》 《快学Scala(中文完整版)》 《HBase权威指南中文版》 《恰如其分的软件架构.风险驱动的设计方法》 《奇点临近》 《分布式服务框架原理与实践_李林锋著》 《Java TCP/IP Socket编程》 《Python Cookbook》 《高性能网站建设指南》 《Groovy_in_Action》 《Java 8 In Action》 《数据结构与算法分析_Java语言描述·Mark Allen Weiss》…有点多，也不一一列举了，上面这些书是主要看了，有些书可以当成字典 用的时候去查看，效果更好。有些书要当成个镜子，每天照一照。比如推荐的系列就是 in_Action系列，和图灵系列，这些系列的书从作者到出版社审核都是很优秀的，看个技术类的书 如果内容质量不高，你看的都是过时的 活着说是错的，就很尴尬了。 经过这一年看技术的发展，谈谈自己的感想： 首先是Java发展太快了，从Lambda到模块化再到马上要出来的Version10的类型自动推断，需要关注的点很多。有总比没有强，有了这些东西的支撑，你在选择使用Java来实现的时候 才有更多选择。 今年TOBO社区显示 明显大家将关注点放在了支持动态的语言上面比如Scala、Python等这些灵活的语言上面。因为前些年JavaScript以及衍生出来的语言发展迅速，后端语言上也需要跟上脚步。所以新的一年可以多关注一些支持动态的语言上面。 当当当，Github上AI开源的东西，要看 要看 要看。前些日子拿了Facebook开源预测框架prophet试试手，这种时序预测的框架其实有很大作用，在预测房价上。。。哦不是预测价格走势、航班晚点趋势等等 商业用途上有很大优势，因为只需要一个csv文件横轴竖轴的数据就可以预测，很方便。看开源代码也可以学习算法。 最后是自己对行业和发展的想法，计算机语言发展的快速大家都知道，你现在学习的东西 10年以后可能根本用不到，这也不是什么危言耸听。所以思忖着把学习重点可以适当放在架构这一类学习周期时间长，更迭速度慢的东西上 会发挥更大作用。至于框架类的东西，精通几个优秀框架即可，没必要因为招聘上写了一大堆框架熟悉优先，你就去学习所有框架，没这个必要 和 没这个精力，大多可以做到使用API就很不错了。 新年还是要有计划的，多学习 多买彩票。。。（缺钱啊）嗯 多培养自己其他领域的爱好，工作不忙了（不可能的）去重新拿上吉他给自己放松 钓鱼和朋友小聚一下 篮球和撸铁要继续（不然就是药不能停的状态了） 看书也不能停 非技术相关的使劲买买买（技术的就下载电子书） 收集几大主机，玩游戏也很重要 把媳妇骗回家 想学架子鼓 想学木匠技艺（这个怎么说呢。。。房子装修的时候自己给自己做家具吧。。。） 继续保持好奇心「Stay hungry. Stay foolish.」 Less is More 好了，最重要的就是一句话 Less is More还是送上我最喜欢的","tags":[{"name":"2017随笔","slug":"2017随笔","permalink":"https://fantalovelife.club/tags/2017%E9%9A%8F%E7%AC%94/"}]},{"title":"Love","date":"2017-05-07T14:10:26.000Z","path":"2017/05/07/love/love/","text":"在住的地方蜗居不久，以为跳槽到现在的公司会轻松很多，没想到以来就是遇上大版本改造中间件。身体有点吃不消。也许久没有回家了。每周末都定期和父母通话，尤其母亲很是想念。所以今天父母今天也是开车来到住所看望我，前一晚告诉父母没啥带的，不用麻烦了。但还是带了一大包零食和席子,真的很谢谢他们对我的爱","tags":[{"name":"2017随笔","slug":"2017随笔","permalink":"https://fantalovelife.club/tags/2017%E9%9A%8F%E7%AC%94/"}]},{"title":"为了所爱的体育","date":"2017-03-06T13:31:53.000Z","path":"2017/03/06/forsoccer/forsoccer/","text":"&emsp;&emsp;刚刚看完了每周一必看的节目《天下足球》😁 &emsp;&emsp;好吧，其实我只是个伪足球迷，我对足球的热爱完完全全来自那荒度时光（美好时光）的PES8，实况足球国际版。我滴孩，这游戏在零几年还能再火点吗。电脑上，PlayStation上，Xbox上。我都忘了当时有没有Xbox可以玩。反正只要是各个平台上有上线的，实况足球，FIFA，我都要玩个遍。 &emsp;&emsp;记得那时几个哥哥都没成家，过年就是我们的狂欢，那必然少不了去网吧，去游戏厅。我的大哥是最喜欢足球的，所以足球游戏他是不会错过的。每次我们都会玩个很久的PES实况足球。他喜欢AC米兰和皇马，我就是曼联和巴塞罗那。如果是国家队，那他一定是意大利，我就一定是英格兰。反正每次都是我赢😎所以无所谓什么队。 &emsp;&emsp;所以说对足球的喜爱，或者说是对足球的认识，完全是从游戏开始的。但渐渐也喜欢上了足球，不愧是世界第一运动。还记得第一次看足球赛是中国队进入世界杯决赛圈，我的天哪，那时候住在爷爷家。爷爷家客厅的大沙发，放下来就是个床，中国队的比赛基本上夜夜都要熬夜看，家里也不乏和我一样有好几个伪球迷，但是当时的中国队真的可以说是梦之队。像郝海东，李铁这样的球员，现在的中国队真的是差了一大截，但是总的来说，中国队在积极组建和成长中，这是好事。虽然我最喜欢的运动是篮球，而且基本上到现在都保持着每周一次的频率去践行自己喜欢的运动。但是足球真的可以说是我所爱的运动。场上胜利11人的队伍，为了同一个目标在绿荫上奔跑真的可以说是个伟大的运动。💪🏿比起篮球的观赏性，足球更多的是代表了一种精神。这也是我最喜欢的。 &emsp;&emsp;所以说你不看足球，你不知道有些人定义了足球中的一些动作。你不知道罗纳尔多的钟摆过人，你不知道齐达内的马赛回旋，你不知道小罗的牛尾巴，你不知道禁区旁有个皮耶罗区域，你不知道巴蒂式进球，你不知道班克斯式扑救，你不知道克鲁伊夫转身，你不知道勺子点球，你不知道蝎子摆尾，你不知道彩虹过人和蛙跳过人，你不知道贝式弧线，你也不知道有炸丸子和内切射门。","tags":[{"name":"我热爱的","slug":"我热爱的","permalink":"https://fantalovelife.club/tags/%E6%88%91%E7%83%AD%E7%88%B1%E7%9A%84/"}]},{"title":"新公司","date":"2017-02-24T14:15:52.000Z","path":"2017/02/24/newstart/newstart/","text":"离开 &emsp;&emsp;离开了上家公司，自己也是在Research&amp;Develop这个岗位上摸爬滚打了快一年了，从以前搞黑盒到现在的研发，总觉得自己做了不得了的决定。记得在YOHO！的时候，特别希望经理教我白盒和自动化，经理来句，你TM年纪轻轻的，学什么测试，搞开发啊。我一想 是啊，搞什么测试，去学开发去。 &emsp;&emsp;然后跟着我那程序设计老师，去做了个项目，类似今日头条App的后端和后台管理系统，那些日子真是难熬啊。天天买各种书看，几乎每天都要通宵，自己身体也受不住了，还好做完了，也上线了，自己也充实了一把，所以也把这个难熬的事情想成愉悦的经历了。起码我从一个Java初学，学习了数据库，学习了Web相关的知识Servlet‘html’css这些基本，再到传说中的几大框架实现个基本功能。也算是有点入门了，当时自己一个人做出这个后端，还是挺有成就感的，虽然现在看到老的代码觉得逻辑很奇怪，但这些都不是事😅 &emsp;&emsp;后来又来到一个不大不小的外包单位，发现还是自己一个人来负责后端，轻车熟路一般又学习到了Mybatis持久框架，也是自己一个人默默在问，在学习。更宝贵的经验是，我学习到了很多关于整个项目流程的知识，因为后端是我一人负责，开发‘部署’测试的调度也就落到我头上了。虽然当时没接触过，但我还是对经理来了一句么问题。然后自己又从网上下了很多Linux的电子书和Junit的电子书，学会了在Linux环境下自己发布部署，自己去单元测试代码。项目中也用到了很多第三方集成，像极光推送‘即时IM这样的，学习了一些第三方集成的基本知识。学习JSTL‘Bootstrap’Jquery去做更方便的后台管理系统。知道了用Ajax调用接口是多么的方便。也自己去实现了一个短信验证码的功能，从平台调取发送短信，然后保存到数据库中，传Token到App端去双向验证会更安全。这段时间自己负责了很多东西，也学到了很多东西，身边有一群贵人和好同事的帮忙，自己也很开心。 &emsp;&emsp;再后来就来到了上家公司，也接近毕业了🎓，所以说还是很想努力去💪做出一些事情的。来到这里才发现你不仅要明白技术很重要，在一个项目中，去了解业务矩阵也是非常重要的事情，你应该明白参与项目的具体全部业务，也应该明白这个项目或者说这个系统在整个公司中是承担什么职责，是原子的还是复合的，需不需要与外部系统做交互，应该用什么方式去交互，你的每一个功能实现，是不是和大家讨论过实现的方式，以及功能的实现是不是可以有分支或者策略模式去拓展的。你都要考虑。这是非常重要的，也是我在这个公司学到的最宝贵经验。还记得16年元旦给自己定了一个计划。 &emsp;&emsp;当时觉得这计划得流产，毕竟觉得有些多了。没想到就在16年底，除了第一个还都基本完成了。😎公司在新的项目中就是使用了SpringJDBCTemplet+Spring+SpringMVC去实现的，SpringJDBCTemplet以下简称JT，而且是我自己封装了数据访问层，用反射和代理把JT去封装实现了。每次操作都使用这个Jar包去实现数据访问。domin也都封装到Jar中去，让domin更纯洁。也省去了JT很多必须要实现的东西，比如Rower这些东西。自己也成就感很大，毕竟公司都用上了自己封装的东西。 来到&emsp;&emsp;年后，因为各种原因，来到了一家国企上班。怎么说呢，新到一家国企上班。最大的感悟就是，好TM严肃啊。不能上外网，不能用U盘，这让习惯懒散的我不能适应。然后这也是刚来几天的不习惯，发现也是很多的，国企的技术并不是多么落后迂腐，反而和我想的不一样，是非常先进的。有调度中心，有自己开发的中间件（目前在这个部门下），也有很多RPC的应用，有一大推自己封装的相当不错的框架，连构建都用Jenkins，觉得逼格可以啊。 所以说新公司！努力吧少年！","tags":[{"name":"2017随笔","slug":"2017随笔","permalink":"https://fantalovelife.club/tags/2017%E9%9A%8F%E7%AC%94/"}]},{"title":"First Page","date":"2017-01-08T17:21:15.000Z","path":"2017/01/09/FirstPage/","text":"欢迎来到Hexo的世界，Fanta","tags":[]}]